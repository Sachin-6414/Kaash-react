{"ast":null,"code":"import { Vector2, WebGLRenderer, PerspectiveCamera, Scene, PointLight, DirectionalLight, AmbientLight, SplineCurve, Vector3, Color, OrthographicCamera, PlaneGeometry, ShaderMaterial, Mesh, HalfFloatType, BufferGeometry, BufferAttribute, AdditiveBlending, Points, MathUtils, CanvasTexture, InstancedBufferAttribute, DoubleSide, TextureLoader, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, InstancedMesh, SphereGeometry, OctahedronGeometry, ConeGeometry, CapsuleGeometry, BoxGeometry, Float32BufferAttribute, FogExp2 } from 'three';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js';\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';\nfunction pointer(params) {\n  const {\n    domElement,\n    onClick = () => {},\n    onEnter = () => {},\n    onMove = () => {},\n    onLeave = () => {},\n    onDragStart = () => {},\n    onDragMove = () => {},\n    onDragStop = () => {}\n  } = params;\n  const position = new Vector2();\n  const nPosition = new Vector2();\n  const startPosition = new Vector2();\n  const lastPosition = new Vector2();\n  const delta = new Vector2();\n  const obj = {\n    position,\n    nPosition,\n    hover: false,\n    down: false,\n    removeListeners\n  };\n  addListeners();\n  return obj;\n  function pointerClick(e) {\n    if (startPosition.distanceTo(position) < 20) {\n      updatePosition(e);\n      onClick({\n        position,\n        nPosition\n      });\n    }\n  }\n  function pointerEnter(e) {\n    obj.hover = e.pointerType === \"mouse\";\n    updatePosition(e);\n    onEnter({\n      position,\n      nPosition\n    });\n  }\n  function pointerDown(e) {\n    obj.down = true;\n    updatePosition(e);\n    startPosition.copy(position);\n    lastPosition.copy(position);\n    onDragStart({\n      position,\n      nPosition\n    });\n  }\n  function pointerMove(e) {\n    updatePosition(e);\n    delta.copy(position).sub(lastPosition);\n    if (obj.down) {\n      onDragMove({\n        position,\n        nPosition,\n        startPosition,\n        lastPosition,\n        delta\n      });\n    } else {\n      if (!obj.hover) obj.hover = true;\n    }\n    onMove({\n      position,\n      nPosition,\n      startPosition,\n      lastPosition,\n      delta\n    });\n    lastPosition.copy(position);\n  }\n  function pointerUp(e) {\n    obj.down = false;\n    onDragStop();\n  }\n  function pointerLeave(e) {\n    if (obj.down) {\n      obj.down = false;\n      onDragStop();\n    }\n    obj.hover = false;\n    onLeave();\n  }\n  function updatePosition(e) {\n    const rect = domElement.getBoundingClientRect();\n    position.x = e.clientX - rect.left;\n    position.y = e.clientY - rect.top;\n    nPosition.x = position.x / rect.width * 2 - 1;\n    nPosition.y = -(position.y / rect.height) * 2 + 1;\n  }\n  function addListeners() {\n    domElement.addEventListener(\"click\", pointerClick);\n    domElement.addEventListener(\"pointerenter\", pointerEnter);\n    domElement.addEventListener(\"pointerdown\", pointerDown);\n    domElement.addEventListener(\"pointermove\", pointerMove);\n    domElement.addEventListener(\"pointerup\", pointerUp);\n    domElement.addEventListener(\"pointerleave\", pointerLeave);\n  }\n  function removeListeners() {\n    domElement.removeEventListener(\"click\", pointerClick);\n    domElement.removeEventListener(\"pointerenter\", pointerEnter);\n    domElement.removeEventListener(\"pointerdown\", pointerDown);\n    domElement.removeEventListener(\"pointermove\", pointerMove);\n    domElement.removeEventListener(\"pointerup\", pointerUp);\n    domElement.removeEventListener(\"pointerleave\", pointerLeave);\n  }\n}\nfunction three(params) {\n  const options = {\n    el: null,\n    canvas: null,\n    eventsEl: null,\n    width: null,\n    height: null,\n    resize: true,\n    alpha: false,\n    antialias: false,\n    orbitControls: false,\n    init() {},\n    initCamera() {},\n    initScene() {},\n    afterResize() {},\n    beforeRender() {},\n    ...params\n  };\n  const three = {\n    renderer: null,\n    camera: null,\n    scene: null,\n    pointer: null,\n    width: 0,\n    height: 0,\n    wWidth: 0,\n    wHeight: 0,\n    clock: {\n      startTime: 0,\n      time: 0,\n      elapsed: 0\n    },\n    options\n  };\n  let render;\n  let cameraCtrl;\n  init();\n  return three;\n  function init() {\n    var _a, _b, _c, _d, _e;\n    let canvas;\n    if (options.el) {\n      canvas = document.createElement(\"canvas\");\n      options.el.appendChild(canvas);\n    } else if (options.canvas) {\n      canvas = options.canvas;\n    } else {\n      throw new Error(\"Missing parameter : el or canvas is required\");\n    }\n    (_a = options.init) == null ? void 0 : _a.call(options, three);\n    three.renderer = new WebGLRenderer({\n      canvas,\n      alpha: options.alpha,\n      antialias: options.antialias\n    });\n    (_b = options.initRenderer) == null ? void 0 : _b.call(options, three);\n    three.camera = new PerspectiveCamera();\n    three.camera.position.z = 50;\n    (_c = options.initCamera) == null ? void 0 : _c.call(options, three);\n    if (options.orbitControls) {\n      cameraCtrl = new OrbitControls(three.camera, (_d = options.eventsEl) != null ? _d : three.renderer.domElement);\n      cameraCtrl.enableDamping = true;\n      cameraCtrl.dampingFactor = 0.1;\n      if (typeof options.orbitControls === \"object\") {\n        Object.keys(options.orbitControls).forEach(key => {\n          cameraCtrl[key] = options.orbitControls[key];\n        });\n      }\n    }\n    resize();\n    if (options.resize && !options.width && !options.height) {\n      window.addEventListener(\"resize\", resize);\n    }\n    three.scene = new Scene();\n    (_e = options.initScene) == null ? void 0 : _e.call(options, three);\n    initPointer();\n    render = options.render ? options.render : () => {\n      three.renderer.render(three.scene, three.camera);\n    };\n    requestAnimationFrame(timestamp => {\n      three.clock.startTime = three.clock.time = timestamp;\n      requestAnimationFrame(animate);\n    });\n  }\n  function initPointer() {\n    var _a, _b;\n    const pointerOptions = {};\n    if (options.onPointerEnter) {\n      pointerOptions.onEnter = options.onPointerEnter;\n    }\n    if (options.onPointerMove) {\n      pointerOptions.onMove = options.onPointerMove;\n    }\n    if (options.onPointerMove) {\n      pointerOptions.onLeave = options.onPointerLeave;\n    }\n    if (Object.keys(pointerOptions).length > 0) {\n      three.pointer = pointer({\n        domElement: (_b = options.eventsEl) != null ? _b : (_a = options.el) != null ? _a : options.canvas,\n        ...pointerOptions\n      });\n    }\n  }\n  function animate(timestamp) {\n    const {\n      clock\n    } = three;\n    clock.elapsed = timestamp - clock.time;\n    clock.time = timestamp;\n    options.beforeRender(three);\n    if (cameraCtrl) cameraCtrl.update();\n    render(three);\n    requestAnimationFrame(animate);\n  }\n  function resize() {\n    var _a;\n    if (options.width && options.height) {\n      three.width = options.width;\n      three.height = options.height;\n    } else if (options.resize === \"window\") {\n      three.width = window.innerWidth;\n      three.height = window.innerHeight;\n    } else {\n      const parent = three.renderer.domElement.parentElement;\n      three.width = parent.clientWidth;\n      three.height = parent.clientHeight;\n    }\n    three.renderer.setSize(three.width, three.height);\n    three.camera.aspect = three.width / three.height;\n    three.camera.updateProjectionMatrix();\n    if (three.camera instanceof PerspectiveCamera) {\n      const wsize = getCameraViewSize();\n      three.wWidth = wsize[0];\n      three.wHeight = wsize[1];\n    } else {\n      three.wWidth = three.camera.top - three.camera.bottom;\n      three.wHeight = three.camera.right - three.camera.left;\n    }\n    (_a = options.afterResize) == null ? void 0 : _a.call(options, three);\n  }\n  function getCameraViewSize() {\n    const vFOV = three.camera.fov * Math.PI / 180;\n    const h = 2 * Math.tan(vFOV / 2) * Math.abs(three.camera.position.z);\n    const w = h * three.camera.aspect;\n    return [w, h];\n  }\n}\nfunction commonConfig$1(params) {\n  const config = {};\n  const keys = [\"el\", \"canvas\", \"eventsEl\", \"width\", \"height\", \"resize\", \"orbitControls\"];\n  keys.forEach(key => {\n    if (params[key] !== void 0) config[key] = params[key];\n  });\n  return config;\n}\nfunction initLights(scene, lightsConfig) {\n  const lights = [];\n  if (Array.isArray(lightsConfig) && lightsConfig.length > 0) {\n    let light;\n    lightsConfig.forEach(lightConfig => {\n      switch (lightConfig.type) {\n        case \"ambient\":\n          light = new AmbientLight(...lightConfig.params);\n          break;\n        case \"directional\":\n          light = new DirectionalLight(...lightConfig.params);\n          break;\n        case \"point\":\n          light = new PointLight(...lightConfig.params);\n          break;\n        default:\n          console.error(`Unknown light type ${lightConfig.type}`);\n      }\n      if (light) {\n        if (typeof lightConfig.props === \"object\") {\n          Object.keys(lightConfig.props).forEach(key => {\n            if (key === \"position\") {\n              light.position.set(...lightConfig.props[key]);\n            } else light[key] = lightConfig.props[key];\n          });\n        }\n        scene.add(light);\n        lights.push(light);\n      }\n    });\n  }\n  return lights;\n}\nconst defaultConfig$6 = {\n  shaderPoints: 8,\n  curvePoints: 80,\n  curveLerp: 0.75,\n  radius1: 3,\n  radius2: 5,\n  velocityTreshold: 10,\n  sleepRadiusX: 150,\n  sleepRadiusY: 150,\n  sleepTimeCoefX: 25e-4,\n  sleepTimeCoefY: 25e-4\n};\nfunction index$5(params) {\n  const config = {\n    ...defaultConfig$6,\n    ...params\n  };\n  const points = new Array(config.curvePoints).fill(0).map(() => new Vector2());\n  const spline = new SplineCurve(points);\n  const velocity = new Vector3();\n  const velocityTarget = new Vector3();\n  const uRatio = {\n    value: new Vector2()\n  };\n  const uSize = {\n    value: new Vector2()\n  };\n  const uPoints = {\n    value: new Array(config.shaderPoints).fill(0).map(() => new Vector2())\n  };\n  const uColor = {\n    value: new Color(16711935)\n  };\n  let material;\n  let plane;\n  let hover = false;\n  const threeConfig = {};\n  const keys = [\"el\", \"canvas\", \"width\", \"height\", \"resize\"];\n  keys.forEach(key => {\n    if (params[key] !== void 0) threeConfig[key] = params[key];\n  });\n  three({\n    ...threeConfig,\n    antialias: false,\n    initCamera(three2) {\n      three2.camera = new OrthographicCamera();\n    },\n    initScene(_ref) {\n      let {\n        scene\n      } = _ref;\n      const geometry = new PlaneGeometry(2, 2);\n      material = new ShaderMaterial({\n        uniforms: {\n          uRatio,\n          uSize,\n          uPoints,\n          uColor\n        },\n        defines: {\n          SHADER_POINTS: config.shaderPoints\n        },\n        vertexShader: `\n          varying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0);\n          }\n        `,\n        fragmentShader: `\n          // https://www.shadertoy.com/view/wdy3DD\n          // https://www.shadertoy.com/view/MlKcDD\n          // Signed distance to a quadratic bezier\n          float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C) {\n            vec2 a = B - A;\n            vec2 b = A - 2.0*B + C;\n            vec2 c = a * 2.0;\n            vec2 d = A - pos;\n            float kk = 1.0 / dot(b,b);\n            float kx = kk * dot(a,b);\n            float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n            float kz = kk * dot(d,a);\n            float res = 0.0;\n            float p = ky - kx*kx;\n            float p3 = p*p*p;\n            float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n            float h = q*q + 4.0*p3;\n            if(h >= 0.0){\n              h = sqrt(h);\n              vec2 x = (vec2(h, -h) - q) / 2.0;\n              vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n              float t = uv.x + uv.y - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 1 root\n              vec2 qos = d + (c + b*t)*t;\n              res = length(qos);\n            } else {\n              float z = sqrt(-p);\n              float v = acos( q/(p*z*2.0) ) / 3.0;\n              float m = cos(v);\n              float n = sin(v)*1.732050808;\n              vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 3 roots\n              vec2 qos = d + (c + b*t.x)*t.x;\n              float dis = dot(qos,qos);\n              res = dis;\n              qos = d + (c + b*t.y)*t.y;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              qos = d + (c + b*t.z)*t.z;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              res = sqrt( res );\n            }\n            return res;\n          }\n\n          uniform vec2 uRatio;\n          uniform vec2 uSize;\n          uniform vec2 uPoints[SHADER_POINTS];\n          uniform vec3 uColor;\n          varying vec2 vUv;\n          void main() {\n            float intensity = 1.0;\n            float radius = 0.015;\n\n            vec2 pos = (vUv - 0.5) * uRatio;\n\n            vec2 c = (uPoints[0] + uPoints[1]) / 2.0;\n            vec2 c_prev;\n            float dist = 10000.0;\n            for(int i = 0; i < SHADER_POINTS - 1; i++){\n              c_prev = c;\n              c = (uPoints[i] + uPoints[i + 1]) / 2.0;\n              dist = min(dist, sdBezier(pos, c_prev, uPoints[i], c));\n            }\n            dist = max(0.0, dist);\n\n            float glow = pow(uSize.y / dist, intensity);\n            vec3 col = vec3(0.0);\n            col += 10.0 * vec3(smoothstep(uSize.x, 0.0, dist));\n            col += glow * uColor;\n\n            // Tone mapping\n            col = 1.0 - exp(-col);\n            col = pow(col, vec3(0.4545));\n  \n            gl_FragColor = vec4(col, 1.0);\n          }\n        `\n      });\n      plane = new Mesh(geometry, material);\n      scene.add(plane);\n    },\n    afterResize(_ref2) {\n      let {\n        width,\n        height\n      } = _ref2;\n      uSize.value.set(config.radius1, config.radius2);\n      if (width >= height) {\n        uRatio.value.set(1, height / width);\n        uSize.value.multiplyScalar(1 / width);\n      } else {\n        uRatio.value.set(width / height, 1);\n        uSize.value.multiplyScalar(1 / height);\n      }\n    },\n    beforeRender(_ref3) {\n      let {\n        clock,\n        width,\n        height,\n        wWidth\n      } = _ref3;\n      for (let i = 1; i < config.curvePoints; i++) {\n        points[i].lerp(points[i - 1], config.curveLerp);\n      }\n      for (let i = 0; i < config.shaderPoints; i++) {\n        spline.getPoint(i / (config.shaderPoints - 1), uPoints.value[i]);\n      }\n      if (!hover) {\n        const t1 = clock.time * config.sleepTimeCoefX;\n        const t2 = clock.time * config.sleepTimeCoefY;\n        const cos = Math.cos(t1);\n        const sin = Math.sin(t2);\n        const r1 = config.sleepRadiusX * wWidth / width;\n        const r2 = config.sleepRadiusY * wWidth / width;\n        const x = r1 * cos;\n        const y = r2 * sin;\n        spline.points[0].set(x, y);\n        uColor.value.r = 0.5 + 0.5 * Math.cos(clock.time * 15e-4);\n        uColor.value.g = 0;\n        uColor.value.b = 1 - uColor.value.r;\n      } else {\n        uColor.value.r = velocity.z;\n        uColor.value.g = 0;\n        uColor.value.b = 1 - velocity.z;\n        velocity.multiplyScalar(0.95);\n      }\n    },\n    onPointerMove(_ref4) {\n      let {\n        nPosition,\n        delta\n      } = _ref4;\n      hover = true;\n      const x = 0.5 * nPosition.x * uRatio.value.x;\n      const y = 0.5 * nPosition.y * uRatio.value.y;\n      spline.points[0].set(x, y);\n      velocityTarget.x = Math.min(velocity.x + Math.abs(delta.x) / config.velocityTreshold, 1);\n      velocityTarget.y = Math.min(velocity.y + Math.abs(delta.y) / config.velocityTreshold, 1);\n      velocityTarget.z = Math.sqrt(velocityTarget.x * velocityTarget.x + velocityTarget.y * velocityTarget.y);\n      velocity.lerp(velocityTarget, 0.05);\n    },\n    onPointerLeave() {\n      hover = false;\n    }\n  });\n  return {\n    config\n  };\n}\nfunction colorScale(colors) {\n  let range = [];\n  setColors(colors);\n  const dummy = new Color();\n  return {\n    setColors,\n    getColorAt\n  };\n  function setColors(colors2) {\n    range = [];\n    colors2.forEach(color => {\n      range.push(new Color(color));\n    });\n  }\n  function getColorAt(progress) {\n    const p = Math.max(0, Math.min(1, progress)) * (colors.length - 1);\n    const i1 = Math.floor(p);\n    const c1 = range[i1];\n    if (i1 === colors.length - 1) {\n      return c1.getHex();\n    }\n    const p1 = p - i1;\n    const c2 = range[i1 + 1];\n    dummy.r = c1.r + p1 * (c2.r - c1.r);\n    dummy.g = c1.g + p1 * (c2.g - c1.g);\n    dummy.b = c1.b + p1 * (c2.b - c1.b);\n    return dummy.clone();\n  }\n}\nvar psrdnoise$1 = \"vec4 permute(vec4 x){vec4 xm=mod(x,289.0);return mod(((xm*34.0)+10.0)*xm,289.0);}float psrdnoise(vec3 x,vec3 period,float alpha,out vec3 gradient){\\n#ifndef PERLINGRID\\nconst mat3 M=mat3(0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0);const mat3 Mi=mat3(-0.5,0.5,0.5,0.5,-0.5,0.5,0.5,0.5,-0.5);\\n#endif\\nvec3 uvw;\\n#ifndef PERLINGRID\\nuvw=M*x;\\n#else\\nuvw=x+dot(x,vec3(1.0/3.0));\\n#endif\\nvec3 i0=floor(uvw);vec3 f0=fract(uvw);vec3 g_=step(f0.xyx,f0.yzz);vec3 l_=1.0-g_;vec3 g=vec3(l_.z,g_.xy);vec3 l=vec3(l_.xy,g_.z);vec3 o1=min(g,l);vec3 o2=max(g,l);vec3 i1=i0+o1;vec3 i2=i0+o2;vec3 i3=i0+vec3(1.0);vec3 v0,v1,v2,v3;\\n#ifndef PERLINGRID\\nv0=Mi*i0;v1=Mi*i1;v2=Mi*i2;v3=Mi*i3;\\n#else\\nv0=i0-dot(i0,vec3(1.0/6.0));v1=i1-dot(i1,vec3(1.0/6.0));v2=i2-dot(i2,vec3(1.0/6.0));v3=i3-dot(i3,vec3(1.0/6.0));\\n#endif\\nvec3 x0=x-v0;vec3 x1=x-v1;vec3 x2=x-v2;vec3 x3=x-v3;if(any(greaterThan(period,vec3(0.0)))){vec4 vx=vec4(v0.x,v1.x,v2.x,v3.x);vec4 vy=vec4(v0.y,v1.y,v2.y,v3.y);vec4 vz=vec4(v0.z,v1.z,v2.z,v3.z);if(period.x>0.0)vx=mod(vx,period.x);if(period.y>0.0)vy=mod(vy,period.y);if(period.z>0.0)vz=mod(vz,period.z);\\n#ifndef PERLINGRID\\ni0=M*vec3(vx.x,vy.x,vz.x);i1=M*vec3(vx.y,vy.y,vz.y);i2=M*vec3(vx.z,vy.z,vz.z);i3=M*vec3(vx.w,vy.w,vz.w);\\n#else\\nv0=vec3(vx.x,vy.x,vz.x);v1=vec3(vx.y,vy.y,vz.y);v2=vec3(vx.z,vy.z,vz.z);v3=vec3(vx.w,vy.w,vz.w);i0=v0+dot(v0,vec3(1.0/3.0));i1=v1+dot(v1,vec3(1.0/3.0));i2=v2+dot(v2,vec3(1.0/3.0));i3=v3+dot(v3,vec3(1.0/3.0));\\n#endif\\ni0=floor(i0+0.5);i1=floor(i1+0.5);i2=floor(i2+0.5);i3=floor(i3+0.5);}vec4 hash=permute(permute(permute(vec4(i0.z,i1.z,i2.z,i3.z))+vec4(i0.y,i1.y,i2.y,i3.y))+vec4(i0.x,i1.x,i2.x,i3.x));vec4 theta=hash*3.883222077;vec4 sz=hash*-0.006920415+0.996539792;vec4 psi=hash*0.108705628;vec4 Ct=cos(theta);vec4 St=sin(theta);vec4 sz_prime=sqrt(1.0-sz*sz);vec4 gx,gy,gz;\\n#ifdef FASTROTATION\\nvec4 qx=St;vec4 qy=-Ct;vec4 qz=vec4(0.0);vec4 px=sz*qy;vec4 py=-sz*qx;vec4 pz=sz_prime;psi+=alpha;vec4 Sa=sin(psi);vec4 Ca=cos(psi);gx=Ca*px+Sa*qx;gy=Ca*py+Sa*qy;gz=Ca*pz+Sa*qz;\\n#else\\nif(alpha!=0.0){vec4 Sp=sin(psi);vec4 Cp=cos(psi);vec4 px=Ct*sz_prime;vec4 py=St*sz_prime;vec4 pz=sz;vec4 Ctp=St*Sp-Ct*Cp;vec4 qx=mix(Ctp*St,Sp,sz);vec4 qy=mix(-Ctp*Ct,Cp,sz);vec4 qz=-(py*Cp+px*Sp);vec4 Sa=vec4(sin(alpha));vec4 Ca=vec4(cos(alpha));gx=Ca*px+Sa*qx;gy=Ca*py+Sa*qy;gz=Ca*pz+Sa*qz;}else{gx=Ct*sz_prime;gy=St*sz_prime;gz=sz;}\\n#endif\\nvec3 g0=vec3(gx.x,gy.x,gz.x);vec3 g1=vec3(gx.y,gy.y,gz.y);vec3 g2=vec3(gx.z,gy.z,gz.z);vec3 g3=vec3(gx.w,gy.w,gz.w);vec4 w=0.5-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3));w=max(w,0.0);vec4 w2=w*w;vec4 w3=w2*w;vec4 gdotx=vec4(dot(g0,x0),dot(g1,x1),dot(g2,x2),dot(g3,x3));float n=dot(w3,gdotx);vec4 dw=-6.0*w2*gdotx;vec3 dn0=w3.x*g0+dw.x*x0;vec3 dn1=w3.y*g1+dw.y*x1;vec3 dn2=w3.z*g2+dw.z*x2;vec3 dn3=w3.w*g3+dw.w*x3;gradient=39.5*(dn0+dn1+dn2+dn3);return 39.5*n;}\";\nconst {\n  randFloat: rnd$3,\n  randFloatSpread: rndFS$3\n} = MathUtils;\nconst defaultConfig$5 = {\n  gpgpuSize: 256,\n  colors: [65280, 255],\n  color: 16711680,\n  coordScale: 1.5,\n  noiseIntensity: 1e-3,\n  noiseTimeCoef: 1e-4,\n  pointSize: 5,\n  pointDecay: 5e-3,\n  sleepRadiusX: 250,\n  sleepRadiusY: 250,\n  sleepTimeCoefX: 1e-3,\n  sleepTimeCoefY: 2e-3\n};\nfunction index$4(params) {\n  const config = {\n    ...defaultConfig$5,\n    ...params\n  };\n  const WIDTH = config.gpgpuSize;\n  const COUNT = WIDTH * WIDTH;\n  let gpu;\n  let dtPosition, dtVelocity;\n  let velocityVariable, positionVariable;\n  const uTime = {\n    value: 0\n  };\n  const uCoordScale = {\n    value: config.coordScale\n  };\n  const uNoiseIntensity = {\n    value: config.noiseIntensity\n  };\n  const uPointSize = {\n    value: config.pointSize\n  };\n  const uPointDecay = {\n    value: config.pointDecay\n  };\n  const uColor = {\n    value: new Color(config.color)\n  };\n  const uMouse = {\n    value: new Vector2()\n  };\n  const uMouseDirection = {\n    value: new Vector2()\n  };\n  const uniforms = {\n    uTime,\n    uCoordScale,\n    uNoiseIntensity,\n    uPointSize,\n    uPointDecay,\n    uColor,\n    uMouse,\n    uMouseDirection\n  };\n  let geometry, material, mesh;\n  let hover = false;\n  const mouseTarget = new Vector2();\n  three({\n    ...commonConfig(params),\n    antialias: false,\n    initRenderer(_ref5) {\n      let {\n        renderer\n      } = _ref5;\n      initGPU(renderer);\n    },\n    initScene(_ref6) {\n      let {\n        scene\n      } = _ref6;\n      initParticles();\n      scene.add(mesh);\n    },\n    beforeRender(_ref7) {\n      let {\n        width,\n        wWidth,\n        wHeight,\n        clock,\n        pointer\n      } = _ref7;\n      if (!hover) {\n        const t1 = clock.time * config.sleepTimeCoefX;\n        const t2 = clock.time * config.sleepTimeCoefY;\n        const cos = Math.cos(t1);\n        const sin = Math.sin(t2);\n        const r1 = config.sleepRadiusX * wWidth / width;\n        const r2 = config.sleepRadiusY * wWidth / width;\n        mouseTarget.x = r1 * cos;\n        mouseTarget.y = r2 * sin;\n      } else {\n        mouseTarget.x = pointer.nPosition.x * 0.5 * wWidth;\n        mouseTarget.y = pointer.nPosition.y * 0.5 * wHeight;\n      }\n      uMouse.value.lerp(mouseTarget, 0.05);\n      uTime.value = clock.time * config.noiseTimeCoef;\n      gpu.compute();\n      material.uniforms.texturePosition.value = gpu.getCurrentRenderTarget(positionVariable).texture;\n      material.uniforms.textureVelocity.value = gpu.getCurrentRenderTarget(velocityVariable).texture;\n    },\n    onPointerMove(_ref8) {\n      let {\n        delta\n      } = _ref8;\n      hover = true;\n      uMouseDirection.value.copy(delta);\n    },\n    onPointerLeave() {\n      hover = false;\n    }\n  });\n  return {\n    config,\n    uniforms\n  };\n  function initGPU(renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType);\n    }\n    dtPosition = gpu.createTexture();\n    dtVelocity = gpu.createTexture();\n    initTextures(dtPosition, dtVelocity);\n    velocityVariable = gpu.addVariable(\"textureVelocity\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0;\n          vel.y = 0.0;\n          vel.z = 0.0;\n        } else {\n          vec3 grad;\n          vec3 p = vec3(0.0);\n          float n = psrdnoise(pos.xyz * uCoordScale, p, uTime, grad);\n          vel.xyz += grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    `, dtVelocity);\n    positionVariable = gpu.addVariable(\"texturePosition\", `\n      uniform float uPointDecay;\n      uniform vec2 uMouse;\n      uniform vec2 uMouseDirection;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uPointDecay;\n        if (pos.w <= 0.0) {\n          pos.xy = uMouse.xy;\n          pos.z = 0.0;\n        } else {\n          pos.xyz += vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    `, dtPosition);\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n    Object.keys(uniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key];\n      positionVariable.material.uniforms[key] = uniforms[key];\n    });\n    const error = gpu.init();\n    if (error !== null) {\n      console.error(error);\n    }\n  }\n  function initParticles() {\n    geometry = new BufferGeometry();\n    const positions = new Float32Array(COUNT * 3);\n    const uvs = new Float32Array(COUNT * 2);\n    const colors = new Float32Array(COUNT * 3);\n    for (let i = 0; i < COUNT * 3; i += 3) {\n      positions[i] = 0;\n      positions[i + 1] = 0;\n      positions[i + 2] = 0;\n    }\n    let index = 0;\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        uvs[index++] = i / (WIDTH - 1);\n        uvs[index++] = j / (WIDTH - 1);\n      }\n    }\n    const cscale = colorScale(config.colors);\n    for (let i = 0; i < COUNT * 3; i += 3) {\n      const color = cscale.getColorAt(Math.random());\n      colors[i] = color.r;\n      colors[i + 1] = color.g;\n      colors[i + 2] = color.b;\n    }\n    geometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n    geometry.setAttribute(\"uv\", new BufferAttribute(uvs, 2));\n    geometry.setAttribute(\"color\", new BufferAttribute(colors, 3));\n    material = new ShaderMaterial({\n      blending: AdditiveBlending,\n      depthTest: false,\n      transparent: true,\n      vertexColors: true,\n      uniforms: {\n        texturePosition: {\n          value: null\n        },\n        textureVelocity: {\n          value: null\n        },\n        uPointSize,\n        uColor\n      },\n      vertexShader: `\n        uniform sampler2D texturePosition;\n        uniform sampler2D textureVelocity;\n        uniform float uPointSize;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          vCol = color;\n          vPos = texture2D(texturePosition, uv);\n          vVel = texture2D(textureVelocity, uv);\n          vec4 mvPosition = modelViewMatrix * vec4(vPos.xyz, 1.0);\n          // gl_PointSize = smoothstep(0.0, 2.0, vPos.w) * uPointSize;\n          gl_PointSize = vPos.w * (vVel.w + 0.5) * uPointSize;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform vec3 uColor;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n          // float a = smoothstep(0.0, 1.0, vPos.w);\n          gl_FragColor = vec4(mix(vCol, uColor, vPos.w), vPos.w);\n        }\n      `\n    });\n    mesh = new Points(geometry, material);\n    mesh.matrixAutoUpdate = false;\n    mesh.updateMatrix();\n  }\n  function initTextures(texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data;\n    const velArray = textureVelocity.image.data;\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS$3(1);\n      posArray[k + 1] = rndFS$3(1);\n      posArray[k + 2] = -1e5;\n      posArray[k + 3] = rnd$3(0.1, 1);\n      velArray[k + 0] = 0;\n      velArray[k + 1] = 0;\n      velArray[k + 2] = 0;\n      velArray[k + 3] = rnd$3(0.1, 1);\n    }\n  }\n}\nfunction commonConfig(params) {\n  const config = {};\n  const keys = [\"el\", \"canvas\", \"width\", \"height\", \"resize\"];\n  keys.forEach(key => {\n    if (params[key] !== void 0) config[key] = params[key];\n  });\n  return config;\n}\nconst defaultConfig$4 = {\n  width: 256,\n  height: 256\n};\nfunction useCanvasTexture(params) {\n  const config = {\n    ...defaultConfig$4,\n    ...params\n  };\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = config.width;\n  canvas.height = config.height;\n  const ctx = canvas.getContext(\"2d\");\n  const texture = new CanvasTexture(ctx.canvas);\n  return {\n    canvas,\n    ctx,\n    texture\n  };\n}\nvar psrdnoise = \"float psrdnoise(vec2 x,vec2 period,float alpha,out vec2 gradient){vec2 uv=vec2(x.x+x.y*0.5,x.y);vec2 i0=floor(uv);vec2 f0=fract(uv);float cmp=step(f0.y,f0.x);vec2 o1=vec2(cmp,1.0-cmp);vec2 i1=i0+o1;vec2 i2=i0+vec2(1.0,1.0);vec2 v0=vec2(i0.x-i0.y*0.5,i0.y);vec2 v1=vec2(v0.x+o1.x-o1.y*0.5,v0.y+o1.y);vec2 v2=vec2(v0.x+0.5,v0.y+1.0);vec2 x0=x-v0;vec2 x1=x-v1;vec2 x2=x-v2;vec3 iu,iv;vec3 xw,yw;if(any(greaterThan(period,vec2(0.0)))){xw=vec3(v0.x,v1.x,v2.x);yw=vec3(v0.y,v1.y,v2.y);if(period.x>0.0)xw=mod(vec3(v0.x,v1.x,v2.x),period.x);if(period.y>0.0)yw=mod(vec3(v0.y,v1.y,v2.y),period.y);iu=floor(xw+0.5*yw+0.5);iv=floor(yw+0.5);}else{iu=vec3(i0.x,i1.x,i2.x);iv=vec3(i0.y,i1.y,i2.y);}vec3 hash=mod(iu,289.0);hash=mod((hash*51.0+2.0)*hash+iv,289.0);hash=mod((hash*34.0+10.0)*hash,289.0);vec3 psi=hash*0.07482+alpha;vec3 gx=cos(psi);vec3 gy=sin(psi);vec2 g0=vec2(gx.x,gy.x);vec2 g1=vec2(gx.y,gy.y);vec2 g2=vec2(gx.z,gy.z);vec3 w=0.8-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2));w=max(w,0.0);vec3 w2=w*w;vec3 w4=w2*w2;vec3 gdotx=vec3(dot(g0,x0),dot(g1,x1),dot(g2,x2));float n=dot(w4,gdotx);vec3 w3=w2*w;vec3 dw=-8.0*w3*gdotx;vec2 dn0=w4.x*g0+dw.x*x0;vec2 dn1=w4.y*g1+dw.y*x1;vec2 dn2=w4.z*g2+dw.z*x2;gradient=10.9*(dn0+dn1+dn2);return 10.9*n;}\";\nconst defaultConfig$3 = {\n  colors: [16777215, 0],\n  minStroke: 5,\n  maxStroke: 5,\n  timeCoef: 5e-4,\n  coordScale: 2,\n  displacementScale: 2e-3,\n  mouseScale: 0.25,\n  mouseLerp: 0.025\n};\nfunction index$3(params) {\n  const config = {\n    ...defaultConfig$3,\n    ...params\n  };\n  const canvasTexture = useCanvasTexture({\n    width: 1,\n    height: 4096\n  });\n  drawTexture();\n  const uniforms = {\n    uMap: {\n      value: canvasTexture.texture\n    },\n    uTime: {\n      value: 0\n    },\n    uCoordScale: {\n      value: config.coordScale\n    },\n    uDisplacementScale: {\n      value: config.displacementScale\n    },\n    uMouse: {\n      value: new Vector2()\n    }\n  };\n  const geometry = new PlaneGeometry();\n  const material = new ShaderMaterial({\n    uniforms,\n    vertexShader: `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uMap;\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uDisplacementScale;\n      uniform vec2 uMouse;\n      varying vec2 vUv;\n      ${psrdnoise}\n      void main() {\n        vec2 p = vec2(0.0);\n        vec2 grad;\n        float n = psrdnoise(vUv * uCoordScale + uMouse, p, uTime, grad);\n        // grad *= uCoordScale;\n        vec2 uv = vUv + uDisplacementScale * grad;\n        gl_FragColor = texture2D(uMap, uv.yx);\n      }\n    `\n  });\n  const mesh = new Mesh(geometry, material);\n  const mouseTarget = new Vector2();\n  const threeConfig = {};\n  const keys = [\"el\", \"canvas\", \"width\", \"height\", \"resize\"];\n  keys.forEach(key => {\n    if (params[key] !== void 0) threeConfig[key] = params[key];\n  });\n  three({\n    ...threeConfig,\n    antialias: true,\n    initScene(_ref9) {\n      let {\n        camera,\n        scene,\n        wWidth,\n        wHeight\n      } = _ref9;\n      mesh.scale.set(wWidth * 2, wHeight * 2, 1);\n      scene.add(mesh);\n      camera.position.set(0, -30, 7);\n      camera.lookAt(0, -19, 0);\n    },\n    beforeRender(_ref10) {\n      let {\n        clock\n      } = _ref10;\n      uniforms.uTime.value = clock.time * config.timeCoef;\n      uniforms.uMouse.value.lerp(mouseTarget, config.mouseLerp);\n    },\n    onPointerMove(_ref11) {\n      let {\n        nPosition\n      } = _ref11;\n      mouseTarget.set(-nPosition.x, nPosition.y).multiplyScalar(config.mouseScale);\n    },\n    onPointerLeave() {\n      mouseTarget.set(0, 0);\n    }\n  });\n  return {\n    config,\n    uniforms,\n    drawTexture\n  };\n  function drawTexture() {\n    const ctx = canvasTexture.ctx;\n    ctx.lineWidth = 0;\n    const {\n      width,\n      height\n    } = canvasTexture.canvas;\n    const cscale = colorScale(config.colors);\n    let y = 0;\n    let dy;\n    while (y < height) {\n      dy = config.minStroke + Math.random() * (config.maxStroke - config.minStroke);\n      ctx.fillStyle = cscale.getColorAt(Math.random()).getStyle();\n      ctx.beginPath();\n      ctx.rect(0, y - 1, width, dy + 1);\n      ctx.fill();\n      ctx.closePath();\n      y += dy;\n    }\n    canvasTexture.texture.needsUpdate = true;\n  }\n}\nconst {\n  randFloat: rnd$2,\n  randFloatSpread: rndFS$2\n} = MathUtils;\nconst defaultConfig$2 = {\n  gpgpuSize: 64,\n  background: 16777215,\n  material: \"basic\",\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [16777215, 16777215],\n  lights: [{\n    type: \"ambient\",\n    params: [16777215, 0.5]\n  }, {\n    type: \"directional\",\n    params: [16777215, 1],\n    props: {\n      position: [0, 10, 0]\n    }\n  }],\n  wingsScale: [1, 1, 1],\n  wingsWidthSegments: 8,\n  wingsHeightSegments: 8,\n  wingsSpeed: 0.75,\n  wingsDisplacementScale: 1.25,\n  noiseCoordScale: 0.01,\n  noiseTimeCoef: 5e-4,\n  noiseIntensity: 25e-4,\n  attractionRadius1: 100,\n  attractionRadius2: 150,\n  maxVelocity: 0.1\n};\nfunction index$2(params) {\n  const config = {\n    ...defaultConfig$2,\n    ...params\n  };\n  if (![\"basic\", \"phong\", \"standard\"].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`);\n  }\n  if (!Number.isInteger(config.wingsWidthSegments) || config.wingsWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid wingsWidthSegments ${config.wingsWidthSegments}`);\n  }\n  const WIDTH = config.gpgpuSize;\n  const COUNT = WIDTH * WIDTH;\n  let gpu;\n  let dtPosition, dtVelocity;\n  let velocityVariable, positionVariable;\n  const uTexturePosition = {\n    value: null\n  };\n  const uOldTexturePosition = {\n    value: null\n  };\n  const uTextureVelocity = {\n    value: null\n  };\n  const uTime = {\n    value: 0\n  };\n  const uNoiseCoordScale = {\n    value: config.noiseCoordScale\n  };\n  const uNoiseIntensity = {\n    value: config.noiseIntensity\n  };\n  const uMaxVelocity = {\n    value: config.maxVelocity\n  };\n  const uAttractionRadius1 = {\n    value: config.attractionRadius1\n  };\n  const uAttractionRadius2 = {\n    value: config.attractionRadius2\n  };\n  const uWingsScale = {\n    value: new Vector3(...config.wingsScale)\n  };\n  const uWingsSpeed = {\n    value: config.wingsSpeed\n  };\n  const uWingsDisplacementScale = {\n    value: config.wingsDisplacementScale\n  };\n  const gpuTexturesUniforms = {\n    uTexturePosition,\n    uOldTexturePosition,\n    uTextureVelocity\n  };\n  const commonUniforms = {\n    uTime,\n    uNoiseCoordScale,\n    uNoiseIntensity,\n    uMaxVelocity,\n    uAttractionRadius1,\n    uAttractionRadius2,\n    uWingsScale,\n    uWingsSpeed,\n    uWingsDisplacementScale\n  };\n  const uniforms = {\n    ...gpuTexturesUniforms,\n    ...commonUniforms\n  };\n  let geometry, material, iMesh;\n  const _three = three({\n    ...commonConfig$1(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer(_ref12) {\n      let {\n        renderer\n      } = _ref12;\n      initGPU(renderer);\n    },\n    initCamera(_ref13) {\n      let {\n        camera\n      } = _ref13;\n      camera.position.set(0, 50, 70);\n    },\n    initScene(_ref14) {\n      let {\n        scene\n      } = _ref14;\n      initScene(scene);\n    },\n    beforeRender(_ref15) {\n      let {\n        clock\n      } = _ref15;\n      uTime.value = clock.time * config.noiseTimeCoef;\n      gpu.compute();\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture;\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture;\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture;\n    }\n  });\n  return {\n    three: _three,\n    config,\n    uniforms,\n    setColors\n  };\n  function initGPU(renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType);\n    }\n    dtPosition = gpu.createTexture();\n    dtVelocity = gpu.createTexture();\n    initTextures(dtPosition, dtVelocity);\n    velocityVariable = gpu.addVariable(\"textureVelocity\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uWingsSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uWingsSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity);\n    positionVariable = gpu.addVariable(\"texturePosition\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition);\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key];\n      positionVariable.material.uniforms[key] = uniforms[key];\n    });\n    const error = gpu.init();\n    if (error !== null) {\n      throw new Error(error);\n    }\n  }\n  function initScene(scene) {\n    if (config.background !== void 0) {\n      scene.background = new Color(config.background);\n    }\n    initLights(scene, config.lights);\n    geometry = new PlaneGeometry(2, 2, config.wingsWidthSegments, config.wingsHeightSegments).rotateX(Math.PI / 2);\n    const gpuUvs = new Float32Array(COUNT * 2);\n    const mapIndexes = new Float32Array(COUNT);\n    let i1 = 0;\n    let i2 = 0;\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1);\n        gpuUvs[i1++] = j / (WIDTH - 1);\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount);\n      }\n    }\n    geometry.setAttribute(\"gpuUv\", new InstancedBufferAttribute(gpuUvs, 2));\n    geometry.setAttribute(\"mapIndex\", new InstancedBufferAttribute(mapIndexes, 1));\n    const materialParams = {\n      side: DoubleSide,\n      ...config.materialParams\n    };\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture);\n    }\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== \"basic\",\n        WINGS_WIDTH_SEGMENTS: config.wingsWidthSegments,\n        WINGS_HEIGHT_SEGMENTS: config.wingsHeightSegments,\n        WINGS_DX: (2 / config.wingsWidthSegments).toFixed(10),\n        WINGS_DZ: (2 / config.wingsHeightSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      };\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key];\n      });\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uWingsScale;\n        uniform float uWingsDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n\n        mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n          vec3 z = target - origin;\n          if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n          z = normalize(z);\n          vec3 x = cross(up, z);\n          if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n            if (abs(up.z) == 1.0) { z.x += 0.0001; }\n            else { z.z += 0.0001; }\n            x = cross(up, z);\n          }\n          x = normalize(x);\n          vec3 y = cross(z, x);\n          return mat3(x, y, z);\n        }\n\n        mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n          return mat4(\n            rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n            rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n            rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n            pos.x, pos.y, pos.z, 1.0\n          );\n        }\n      ` + shader.vertexShader;\n      shader.vertexShader = shader.vertexShader.replace(\"#include <defaultnormal_vertex>\", \"\");\n      shader.vertexShader = shader.vertexShader.replace(\"#include <normal_vertex>\", \"\");\n      shader.vertexShader = shader.vertexShader.replace(\"#include <begin_vertex>\", `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uWingsScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dx = abs(transformed.x);\n        if (dx > 0.0) {\n          float sdx = smoothstep(0.0, 1.0 + WINGS_DX, dx);\n          #if WINGS_HEIGHT_SEGMENTS > 1\n            float dz = transformed.z + 1.0;\n            float sdz = smoothstep(0.0, 2.0 + WINGS_DZ, dz);\n            transformed.y = sin(vVel.w - sdx + sdz) * sdx * uWingsDisplacementScale;\n          #else\n            transformed.y = sin(vVel.w - sdx) * sdx * uWingsDisplacementScale;\n          #endif\n\n          #ifdef COMPUTE_NORMALS\n            #if WINGS_HEIGHT_SEGMENTS > 1\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float sdz1 = smoothstep(0.0, 2.0 + WINGS_DZ, dz + WINGS_DZ);\n              float dvy1 = sin(vVel.w - sdx + sdz1) * sdx * uWingsDisplacementScale - transformed.y;\n              float dvy2 = sin(vVel.w - sdx1 + sdz) * sdx1 * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, dvy1, s * WINGS_DZ);\n              vec3 v2 = vec3(s * WINGS_DX, dvy2, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #else\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float dvy1 = sin(vVel.w - sdx1) * sdx * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, 0.0, s);\n              vec3 v2 = vec3(s * WINGS_DX, dvy1, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #endif  \n          #endif\n        }\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `);\n      shader.vertexShader = shader.vertexShader.replace(\"#include <project_vertex>\", `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `);\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader;\n      shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_fragment>\", `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `);\n    };\n    switch (config.material) {\n      case \"standard\":\n        material = new MeshStandardMaterial(materialParams);\n        break;\n      case \"phong\":\n        material = new MeshPhongMaterial(materialParams);\n        break;\n      default:\n        material = new MeshBasicMaterial(materialParams);\n    }\n    iMesh = new InstancedMesh(geometry, material, COUNT);\n    setColors(config.colors);\n    scene.add(iMesh);\n  }\n  function setColors(colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors);\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT));\n      }\n      iMesh.instanceColor.needsUpdate = true;\n    }\n  }\n  function initTextures(texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data;\n    const velArray = textureVelocity.image.data;\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS$2(150);\n      posArray[k + 1] = rndFS$2(150);\n      posArray[k + 2] = rndFS$2(150);\n      posArray[k + 3] = rnd$2(0.1, 1);\n      velArray[k + 0] = rndFS$2(0.5);\n      velArray[k + 1] = rndFS$2(0.5);\n      velArray[k + 2] = rndFS$2(0.5);\n      velArray[k + 3] = 0;\n    }\n  }\n}\nconst {\n  randFloat: rnd$1,\n  randFloatSpread: rndFS$1\n} = MathUtils;\nconst defaultConfig$1 = {\n  gpgpuSize: 256,\n  bloomStrength: 1.5,\n  bloomRadius: 0.5,\n  bloomThreshold: 0.25,\n  colors: [Math.random() * 16777215, Math.random() * 16777215, Math.random() * 16777215],\n  geometry: \"custom\",\n  geometryScale: [1, 1, 1],\n  lights: [{\n    type: \"ambient\",\n    params: [16777215, 0.5]\n  }, {\n    type: \"point\",\n    params: [16777215, 1],\n    props: {\n      position: [0, 0, 0]\n    }\n  }, {\n    type: \"point\",\n    params: [16748640, 0.75],\n    props: {\n      position: [0, -100, -100]\n    }\n  }, {\n    type: \"point\",\n    params: [6328575, 0.75],\n    props: {\n      position: [0, 100, 100]\n    }\n  }],\n  materialParams: {},\n  noiseCoordScale: 0.01,\n  noiseIntensity: 25e-4,\n  noiseTimeCoef: 4e-4,\n  attractionRadius1: 150,\n  attractionRadius2: 250,\n  maxVelocity: 0.25\n};\nfunction index$1(params) {\n  const config = {\n    ...defaultConfig$1,\n    ...params\n  };\n  const WIDTH = config.gpgpuSize;\n  const COUNT = WIDTH * WIDTH;\n  let gpu;\n  let dtPosition, dtVelocity;\n  let velocityVariable, positionVariable;\n  const uTexturePosition = {\n    value: null\n  };\n  const uOldTexturePosition = {\n    value: null\n  };\n  const uTextureVelocity = {\n    value: null\n  };\n  const uScale = {\n    value: new Vector3(...config.geometryScale)\n  };\n  const uTime = {\n    value: 0\n  };\n  const uNoiseCoordScale = {\n    value: config.noiseCoordScale\n  };\n  const uNoiseIntensity = {\n    value: config.noiseIntensity\n  };\n  const uMaxVelocity = {\n    value: config.maxVelocity\n  };\n  const uAttractionRadius1 = {\n    value: config.attractionRadius1\n  };\n  const uAttractionRadius2 = {\n    value: config.attractionRadius2\n  };\n  const uMouse = {\n    value: new Vector3()\n  };\n  const gpuTexturesUniforms = {\n    uTexturePosition,\n    uOldTexturePosition,\n    uTextureVelocity\n  };\n  const commonUniforms = {\n    uScale,\n    uTime,\n    uNoiseCoordScale,\n    uNoiseIntensity,\n    uMaxVelocity,\n    uAttractionRadius1,\n    uAttractionRadius2,\n    uMouse\n  };\n  const uniforms = {\n    ...gpuTexturesUniforms,\n    ...commonUniforms\n  };\n  let effectComposer;\n  let renderPass, bloomPass;\n  let camera;\n  let geometry, material, iMesh;\n  const _three = three({\n    ...commonConfig$1(params),\n    antialias: false,\n    orbitControls: true,\n    initRenderer(_ref16) {\n      let {\n        renderer\n      } = _ref16;\n      initGPU(renderer);\n    },\n    initCamera(three2) {\n      camera = three2.camera;\n      camera.position.z = 70;\n    },\n    initScene(_ref17) {\n      let {\n        renderer,\n        width,\n        height,\n        camera: camera2,\n        scene\n      } = _ref17;\n      initScene(scene);\n      renderPass = new RenderPass(scene, camera2);\n      bloomPass = new UnrealBloomPass(new Vector2(width, height), config.bloomStrength, config.bloomRadius, config.bloomThreshold);\n      effectComposer = new EffectComposer(renderer);\n      effectComposer.addPass(renderPass);\n      effectComposer.addPass(bloomPass);\n    },\n    afterResize(_ref18) {\n      let {\n        width,\n        height\n      } = _ref18;\n      if (effectComposer) effectComposer.setSize(width, height);\n    },\n    beforeRender(_ref19) {\n      let {\n        clock\n      } = _ref19;\n      uTime.value = clock.time * config.noiseTimeCoef;\n      gpu.compute();\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture;\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture;\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture;\n    },\n    render() {\n      effectComposer.render();\n    }\n  });\n  return {\n    three: _three,\n    config,\n    uniforms,\n    setColors\n  };\n  function initGPU(renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType);\n    }\n    dtPosition = gpu.createTexture();\n    dtVelocity = gpu.createTexture();\n    initTextures(dtPosition, dtVelocity);\n    velocityVariable = gpu.addVariable(\"textureVelocity\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        vel.xyz += (pos.w * 0.75) * grad * uNoiseIntensity;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        gl_FragColor = vel;\n      }\n    `, dtVelocity);\n    positionVariable = gpu.addVariable(\"texturePosition\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition);\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key];\n      positionVariable.material.uniforms[key] = uniforms[key];\n    });\n    const error = gpu.init();\n    if (error !== null) {\n      throw new Error(error);\n    }\n  }\n  function initScene(scene) {\n    if (config.background !== void 0) {\n      scene.background = new Color(config.background);\n    }\n    initLights(scene, config.lights);\n    switch (config.geometry) {\n      case \"box\":\n        geometry = new BoxGeometry();\n        break;\n      case \"capsule\":\n        geometry = new CapsuleGeometry(0.2, 1, 4, 8).rotateX(Math.PI / 2);\n        break;\n      case \"cone\":\n        geometry = new ConeGeometry(0.4, 2, 6).rotateX(Math.PI / 2);\n        break;\n      case \"octahedron\":\n        geometry = new OctahedronGeometry(1, 0).rotateX(Math.PI / 2);\n        break;\n      case \"sphere\":\n        geometry = new SphereGeometry(0.5, 8, 8);\n        break;\n      default:\n        geometry = customGeometry(1);\n    }\n    const gpuUvs = new Float32Array(COUNT * 2);\n    let index = 0;\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[index++] = i / (WIDTH - 1);\n        gpuUvs[index++] = j / (WIDTH - 1);\n      }\n    }\n    geometry.setAttribute(\"gpuUv\", new InstancedBufferAttribute(gpuUvs, 2));\n    material = new MeshStandardMaterial({\n      metalness: 0.75,\n      roughness: 0.25,\n      side: DoubleSide,\n      ...config.materialParams,\n      onBeforeCompile: shader => {\n        Object.keys(uniforms).forEach(key => {\n          shader.uniforms[key] = uniforms[key];\n        });\n        shader.vertexShader = `\n          uniform sampler2D uTexturePosition;\n          uniform sampler2D uOldTexturePosition;\n          uniform sampler2D uTextureVelocity;\n          uniform vec3 uScale;\n          attribute vec2 gpuUv;\n          varying vec4 vPos;\n          varying vec4 vVel;\n\n          mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n            vec3 z = target - origin;\n            if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n            z = normalize(z);\n            vec3 x = cross(up, z);\n            if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n              if (abs(up.z) == 1.0) { z.x += 0.0001; }\n              else { z.z += 0.0001; }\n              x = cross(up, z);\n            }\n            x = normalize(x);\n            vec3 y = cross(z, x);\n            return mat3(x, y, z);\n          }\n\n          mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n            return mat4(\n              rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n              rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n              rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n              pos.x, pos.y, pos.z, 1.0\n            );\n          }\n        ` + shader.vertexShader;\n        shader.vertexShader = shader.vertexShader.replace(\"#include <defaultnormal_vertex>\", `\n          vPos = texture2D(uTexturePosition, gpuUv);\n          vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n          vVel = texture2D(uTextureVelocity, gpuUv);\n\n          mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n          mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uScale);\n\n          vec3 transformedNormal = objectNormal;\n          mat3 m = mat3(im);\n          transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n          transformedNormal = m * transformedNormal;\n          transformedNormal = normalMatrix * transformedNormal;\n        `);\n        shader.vertexShader = shader.vertexShader.replace(\"#include <project_vertex>\", `\n          vec4 mvPosition = modelViewMatrix * im * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n        `);\n      }\n    });\n    iMesh = new InstancedMesh(geometry, material, COUNT);\n    setColors(config.colors);\n    scene.add(iMesh);\n  }\n  function setColors(colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors);\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT));\n      }\n      iMesh.instanceColor.needsUpdate = true;\n    }\n  }\n  function initTextures(texturePosition, textureVelocity) {\n    const dummy = new Vector3();\n    const posArray = texturePosition.image.data;\n    const velArray = textureVelocity.image.data;\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      dummy.set(rndFS$1(1), rndFS$1(1), rndFS$1(1)).normalize().multiplyScalar(rndFS$1(config.attractionRadius1 * 2));\n      dummy.toArray(posArray, k);\n      posArray[k + 3] = rnd$1(0.1, 1);\n      dummy.set(0, 0, 0);\n      dummy.toArray(velArray, k);\n      velArray[k + 3] = 0;\n    }\n  }\n}\nfunction customGeometry(size) {\n  const vertices = [{\n    p: [size * 0.5, 0, -size],\n    n: [0, 1, 0]\n  }, {\n    p: [-size * 0.5, 0, -size],\n    n: [0, 1, 0]\n  }, {\n    p: [0, 0, size],\n    n: [0, 1, 0]\n  }, {\n    p: [0, -size * 0.5, -size],\n    n: [1, 0, 0]\n  }, {\n    p: [0, size * 0.5, -size],\n    n: [1, 0, 0]\n  }, {\n    p: [0, 0, size],\n    n: [1, 0, 0]\n  }];\n  const indexes = [0, 1, 2, 3, 4, 5];\n  const positions = [];\n  const normals = [];\n  for (const vertex of vertices) {\n    positions.push(...vertex.p);\n    normals.push(...vertex.n);\n  }\n  const geometry = new BufferGeometry();\n  geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n  geometry.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n  geometry.setIndex(indexes);\n  return geometry;\n}\nconst {\n  randFloat: rnd,\n  randFloatSpread: rndFS\n} = MathUtils;\nconst defaultConfig = {\n  gpgpuSize: 64,\n  background: 16777215,\n  material: \"basic\",\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [16777215, 16777215],\n  lights: [{\n    type: \"ambient\",\n    params: [16777215, 0.5]\n  }, {\n    type: \"directional\",\n    params: [16777215, 0.5],\n    props: {\n      position: [20, 50, 100]\n    }\n  }],\n  fogDensity: 0.01,\n  fishScale: [1, 1, 1],\n  fishWidthSegments: 8,\n  fishSpeed: 1.5,\n  fishDisplacementScale: 0.2,\n  noiseCoordScale: 0.02,\n  noiseTimeCoef: 5e-4,\n  noiseIntensity: 25e-4,\n  attractionRadius1: 50,\n  attractionRadius2: 100,\n  maxVelocity: 0.1\n};\nfunction index(params) {\n  const config = {\n    ...defaultConfig,\n    ...params\n  };\n  if (![\"basic\", \"phong\", \"standard\"].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`);\n  }\n  if (!Number.isInteger(config.fishWidthSegments) || config.fishWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid fishWidthSegments ${config.fishWidthSegments}`);\n  }\n  const WIDTH = config.gpgpuSize;\n  const COUNT = WIDTH * WIDTH;\n  let gpu;\n  let dtPosition, dtVelocity;\n  let velocityVariable, positionVariable;\n  const uTexturePosition = {\n    value: null\n  };\n  const uOldTexturePosition = {\n    value: null\n  };\n  const uTextureVelocity = {\n    value: null\n  };\n  const uTime = {\n    value: 0\n  };\n  const uNoiseCoordScale = {\n    value: config.noiseCoordScale\n  };\n  const uNoiseIntensity = {\n    value: config.noiseIntensity\n  };\n  const uMaxVelocity = {\n    value: config.maxVelocity\n  };\n  const uAttractionRadius1 = {\n    value: config.attractionRadius1\n  };\n  const uAttractionRadius2 = {\n    value: config.attractionRadius2\n  };\n  const uFishScale = {\n    value: new Vector3(...config.fishScale)\n  };\n  const uFishSpeed = {\n    value: config.fishSpeed\n  };\n  const uFishDisplacementScale = {\n    value: config.fishDisplacementScale\n  };\n  const gpuTexturesUniforms = {\n    uTexturePosition,\n    uOldTexturePosition,\n    uTextureVelocity\n  };\n  const commonUniforms = {\n    uTime,\n    uNoiseCoordScale,\n    uNoiseIntensity,\n    uMaxVelocity,\n    uAttractionRadius1,\n    uAttractionRadius2,\n    uFishScale,\n    uFishSpeed,\n    uFishDisplacementScale\n  };\n  const uniforms = {\n    ...gpuTexturesUniforms,\n    ...commonUniforms\n  };\n  let geometry, material, iMesh;\n  const _three = three({\n    ...commonConfig$1(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer(_ref20) {\n      let {\n        renderer\n      } = _ref20;\n      initGPU(renderer);\n    },\n    initCamera(_ref21) {\n      let {\n        camera\n      } = _ref21;\n      camera.position.set(0, 20, 70);\n    },\n    initScene(_ref22) {\n      let {\n        scene\n      } = _ref22;\n      initScene(scene);\n    },\n    beforeRender(_ref23) {\n      let {\n        clock\n      } = _ref23;\n      uTime.value = clock.time * config.noiseTimeCoef;\n      gpu.compute();\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture;\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture;\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture;\n    }\n  });\n  return {\n    three: _three,\n    config,\n    uniforms,\n    setColors\n  };\n  function initGPU(renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer);\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType);\n    }\n    dtPosition = gpu.createTexture();\n    dtVelocity = gpu.createTexture();\n    initTextures(dtPosition, dtVelocity);\n    velocityVariable = gpu.addVariable(\"textureVelocity\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uFishSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uFishSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity);\n    positionVariable = gpu.addVariable(\"texturePosition\", `\n      ${psrdnoise$1}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition);\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable]);\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable]);\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key];\n      positionVariable.material.uniforms[key] = uniforms[key];\n    });\n    const error = gpu.init();\n    if (error !== null) {\n      throw new Error(error);\n    }\n  }\n  function initScene(scene) {\n    if (config.background !== void 0) {\n      scene.background = new Color(config.background);\n      if (config.fogDensity) scene.fog = new FogExp2(config.background, config.fogDensity);\n    }\n    initLights(scene, config.lights);\n    geometry = new PlaneGeometry(2, 1, config.fishWidthSegments, 1).rotateY(Math.PI / 2);\n    const gpuUvs = new Float32Array(COUNT * 2);\n    const mapIndexes = new Float32Array(COUNT);\n    let i1 = 0;\n    let i2 = 0;\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1);\n        gpuUvs[i1++] = j / (WIDTH - 1);\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount);\n      }\n    }\n    geometry.setAttribute(\"gpuUv\", new InstancedBufferAttribute(gpuUvs, 2));\n    geometry.setAttribute(\"mapIndex\", new InstancedBufferAttribute(mapIndexes, 1));\n    const materialParams = {\n      side: DoubleSide,\n      ...config.materialParams\n    };\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture);\n    }\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== \"basic\",\n        FISH_DZ: (2 / config.fishWidthSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      };\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key];\n      });\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uFishScale;\n        uniform float uFishDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n\n        mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n          vec3 z = target - origin;\n          if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n          z = normalize(z);\n          vec3 x = cross(up, z);\n          if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n            if (abs(up.z) == 1.0) { z.x += 0.0001; }\n            else { z.z += 0.0001; }\n            x = cross(up, z);\n          }\n          x = normalize(x);\n          vec3 y = cross(z, x);\n          return mat3(x, y, z);\n        }\n\n        mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n          return mat4(\n            rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n            rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n            rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n            pos.x, pos.y, pos.z, 1.0\n          );\n        }\n      ` + shader.vertexShader;\n      shader.vertexShader = shader.vertexShader.replace(\"#include <defaultnormal_vertex>\", \"\");\n      shader.vertexShader = shader.vertexShader.replace(\"#include <normal_vertex>\", \"\");\n      shader.vertexShader = shader.vertexShader.replace(\"#include <begin_vertex>\", `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uFishScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dz = transformed.z + 1.0;\n        float sdz = smoothstep(2.0, 0.0, dz);\n        transformed.x += sin(vVel.w + dz * PI * 1.5) * sdz * uFishDisplacementScale;\n\n        #ifdef COMPUTE_NORMALS\n          float dz1 = dz - 0.2;\n          float sdz1 = smoothstep(2.0, 0.0, dz1);\n          float dx1 = sin(vVel.w + dz1 * PI * 1.5) * sdz1 * uFishDisplacementScale - transformed.x;\n          vec3 v1 = vec3(dx1, 0.0, -FISH_DZ);\n          vec3 v2 = vec3(0.0, 1.0, 0.0);\n          transformedNormal = normalize(cross(v1, v2));\n        #endif\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `);\n      shader.vertexShader = shader.vertexShader.replace(\"#include <project_vertex>\", `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `);\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader;\n      shader.fragmentShader = shader.fragmentShader.replace(\"#include <map_fragment>\", `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `);\n    };\n    switch (config.material) {\n      case \"standard\":\n        material = new MeshStandardMaterial(materialParams);\n        break;\n      case \"phong\":\n        material = new MeshPhongMaterial(materialParams);\n        break;\n      default:\n        material = new MeshBasicMaterial(materialParams);\n    }\n    iMesh = new InstancedMesh(geometry, material, COUNT);\n    setColors(config.colors);\n    scene.add(iMesh);\n  }\n  function setColors(colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors);\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT));\n      }\n      iMesh.instanceColor.needsUpdate = true;\n    }\n  }\n  function initTextures(texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data;\n    const velArray = textureVelocity.image.data;\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS(100);\n      posArray[k + 1] = rndFS(100);\n      posArray[k + 2] = rndFS(100);\n      posArray[k + 3] = rnd(0.1, 1);\n      velArray[k + 0] = rndFS(0.5);\n      velArray[k + 1] = rndFS(0.5);\n      velArray[k + 2] = rndFS(0.5);\n      velArray[k + 3] = 0;\n    }\n  }\n}\nexport { index$2 as butterfliesBackground, index as fishesBackground, index$5 as neonCursor, index$3 as noisyLinesBackground, index$4 as particlesCursor, index$1 as swarmBackground };","map":{"version":3,"names":["pointer","params","domElement","onClick","onEnter","onMove","onLeave","onDragStart","onDragMove","onDragStop","position","Vector2","nPosition","startPosition","lastPosition","delta","obj","hover","down","removeListeners","addListeners","pointerClick","e","distanceTo","updatePosition","pointerEnter","pointerType","pointerDown","copy","pointerMove","sub","pointerUp","pointerLeave","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","width","height","addEventListener","removeEventListener","three","options","el","canvas","eventsEl","resize","alpha","antialias","orbitControls","init","initCamera","initScene","afterResize","beforeRender","renderer","camera","scene","wWidth","wHeight","clock","startTime","time","elapsed","render","cameraCtrl","_a","_b","_c","_d","_e","document","createElement","appendChild","Error","call","WebGLRenderer","initRenderer","PerspectiveCamera","z","OrbitControls","enableDamping","dampingFactor","Object","keys","forEach","key","window","Scene","initPointer","requestAnimationFrame","timestamp","animate","pointerOptions","onPointerEnter","onPointerMove","onPointerLeave","length","update","innerWidth","innerHeight","parent","parentElement","clientWidth","clientHeight","setSize","aspect","updateProjectionMatrix","wsize","getCameraViewSize","bottom","right","vFOV","fov","Math","PI","h","tan","abs","w","commonConfig$1","commonConfig","config","initLights","lightsConfig","lights","Array","isArray","light","lightConfig","type","AmbientLight","DirectionalLight","PointLight","console","error","props","set","add","push","defaultConfig$6","shaderPoints","curvePoints","curveLerp","radius1","radius2","velocityTreshold","sleepRadiusX","sleepRadiusY","sleepTimeCoefX","sleepTimeCoefY","index$5","points","fill","map","spline","SplineCurve","velocity","Vector3","velocityTarget","uRatio","value","uSize","uPoints","uColor","Color","material","plane","threeConfig","three2","OrthographicCamera","_ref","geometry","PlaneGeometry","ShaderMaterial","uniforms","defines","SHADER_POINTS","vertexShader","fragmentShader","Mesh","_ref2","multiplyScalar","_ref3","i","lerp","getPoint","t1","t2","cos","sin","r1","r2","r","g","b","_ref4","min","sqrt","colorScale","colors","range","setColors","dummy","getColorAt","colors2","color","progress","p","max","i1","floor","c1","getHex","p1","c2","clone","psrdnoise$1","randFloat","rnd$3","randFloatSpread","rndFS$3","MathUtils","defaultConfig$5","gpgpuSize","coordScale","noiseIntensity","noiseTimeCoef","pointSize","pointDecay","index$4","WIDTH","COUNT","gpu","dtPosition","dtVelocity","velocityVariable","positionVariable","uTime","uCoordScale","uNoiseIntensity","uPointSize","uPointDecay","uMouse","uMouseDirection","mesh","mouseTarget","_ref5","initGPU","_ref6","initParticles","_ref7","compute","texturePosition","getCurrentRenderTarget","texture","textureVelocity","_ref8","GPUComputationRenderer","capabilities","isWebGL2","setDataType","HalfFloatType","createTexture","initTextures","addVariable","setVariableDependencies","BufferGeometry","positions","Float32Array","uvs","index","j","cscale","random","setAttribute","BufferAttribute","blending","AdditiveBlending","depthTest","transparent","vertexColors","Points","matrixAutoUpdate","updateMatrix","posArray","image","data","velArray","k","kl","defaultConfig$4","useCanvasTexture","ctx","getContext","CanvasTexture","psrdnoise","defaultConfig$3","minStroke","maxStroke","timeCoef","displacementScale","mouseScale","mouseLerp","index$3","canvasTexture","drawTexture","uMap","uDisplacementScale","_ref9","scale","lookAt","_ref10","_ref11","lineWidth","dy","fillStyle","getStyle","beginPath","closePath","needsUpdate","rnd$2","rndFS$2","defaultConfig$2","background","materialParams","textureCount","wingsScale","wingsWidthSegments","wingsHeightSegments","wingsSpeed","wingsDisplacementScale","noiseCoordScale","attractionRadius1","attractionRadius2","maxVelocity","index$2","includes","Number","isInteger","uTexturePosition","uOldTexturePosition","uTextureVelocity","uNoiseCoordScale","uMaxVelocity","uAttractionRadius1","uAttractionRadius2","uWingsScale","uWingsSpeed","uWingsDisplacementScale","gpuTexturesUniforms","commonUniforms","iMesh","_three","_ref12","_ref13","_ref14","_ref15","renderTargets","currentTextureIndex","rotateX","gpuUvs","mapIndexes","i2","InstancedBufferAttribute","side","DoubleSide","TextureLoader","load","onBeforeCompile","shader","COMPUTE_NORMALS","WINGS_WIDTH_SEGMENTS","WINGS_HEIGHT_SEGMENTS","WINGS_DX","toFixed","WINGS_DZ","TEXTURE_COUNT","replace","MeshStandardMaterial","MeshPhongMaterial","MeshBasicMaterial","InstancedMesh","setColorAt","instanceColor","rnd$1","rndFS$1","defaultConfig$1","bloomStrength","bloomRadius","bloomThreshold","geometryScale","index$1","uScale","effectComposer","renderPass","bloomPass","_ref16","_ref17","camera2","RenderPass","UnrealBloomPass","EffectComposer","addPass","_ref18","_ref19","BoxGeometry","CapsuleGeometry","ConeGeometry","OctahedronGeometry","SphereGeometry","customGeometry","metalness","roughness","normalize","toArray","size","vertices","n","indexes","normals","vertex","Float32BufferAttribute","setIndex","rnd","rndFS","defaultConfig","fogDensity","fishScale","fishWidthSegments","fishSpeed","fishDisplacementScale","uFishScale","uFishSpeed","uFishDisplacementScale","_ref20","_ref21","_ref22","_ref23","fog","FogExp2","rotateY","FISH_DZ"],"sources":["C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\pointer.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\three.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\cursors\\neon\\index.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\tools\\color.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\glsl\\psrdnoise3.glsl","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\cursors\\particles\\index.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\tools\\canvasTexture.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\glsl\\psrdnoise2.glsl","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\backgrounds\\noisy-lines\\index.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\backgrounds\\butterflies\\index.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\backgrounds\\swarm\\index.js","C:\\Users\\sachin\\OneDrive\\Desktop\\kaash-react\\kaash-react\\node_modules\\threejs-toys\\src\\backgrounds\\fishes\\index.js"],"sourcesContent":["import { Vector2 } from 'three'\n\n/**\n * Pointer helper\n * @author Kevin Levron <kevin.levron@gmail.com>\n */\nexport default function (params) {\n  const {\n    domElement,\n    onClick = () => {},\n    onEnter = () => {},\n    onMove = () => {},\n    onLeave = () => {},\n    onDragStart = () => {},\n    onDragMove = () => {},\n    onDragStop = () => {}\n  } = params\n\n  const position = new Vector2()\n  const nPosition = new Vector2()\n  const startPosition = new Vector2()\n  const lastPosition = new Vector2()\n  const delta = new Vector2()\n\n  const obj = { position, nPosition, hover: false, down: false, removeListeners }\n\n  addListeners()\n\n  return obj\n\n  function pointerClick (e) {\n    if (startPosition.distanceTo(position) < 20) {\n      // console.log('pointerClick')\n      updatePosition(e)\n      onClick({ position, nPosition })\n    }\n  }\n\n  function pointerEnter (e) {\n    // console.log('pointerEnter', e)\n    obj.hover = e.pointerType === 'mouse'\n    updatePosition(e)\n    onEnter({ position, nPosition })\n  }\n\n  function pointerDown (e) {\n    // console.log('pointerDown')\n    obj.down = true\n    updatePosition(e)\n    startPosition.copy(position)\n    lastPosition.copy(position)\n    onDragStart({ position, nPosition })\n  }\n\n  function pointerMove (e) {\n    // console.log('pointerMove')\n    updatePosition(e)\n    delta.copy(position).sub(lastPosition)\n    if (obj.down) {\n      onDragMove({ position, nPosition, startPosition, lastPosition, delta })\n    } else {\n      if (!obj.hover) obj.hover = true\n    }\n    onMove({ position, nPosition, startPosition, lastPosition, delta })\n    lastPosition.copy(position)\n  }\n\n  function pointerUp (e) {\n    // console.log('pointerUp')\n    obj.down = false\n    onDragStop()\n  }\n\n  function pointerLeave (e) {\n    // console.log('pointerLeave')\n    if (obj.down) {\n      obj.down = false\n      onDragStop()\n    }\n    obj.hover = false\n    onLeave()\n  }\n\n  function updatePosition (e) {\n    const rect = domElement.getBoundingClientRect()\n    position.x = e.clientX - rect.left\n    position.y = e.clientY - rect.top\n    nPosition.x = (position.x / rect.width) * 2 - 1\n    nPosition.y = -(position.y / rect.height) * 2 + 1\n  }\n\n  function addListeners () {\n    domElement.addEventListener('click', pointerClick)\n    domElement.addEventListener('pointerenter', pointerEnter)\n    domElement.addEventListener('pointerdown', pointerDown)\n    domElement.addEventListener('pointermove', pointerMove)\n    domElement.addEventListener('pointerup', pointerUp)\n    domElement.addEventListener('pointerleave', pointerLeave)\n  }\n\n  function removeListeners () {\n    domElement.removeEventListener('click', pointerClick)\n    domElement.removeEventListener('pointerenter', pointerEnter)\n    domElement.removeEventListener('pointerdown', pointerDown)\n    domElement.removeEventListener('pointermove', pointerMove)\n    domElement.removeEventListener('pointerup', pointerUp)\n    domElement.removeEventListener('pointerleave', pointerLeave)\n  }\n}\n","import {\n  AmbientLight,\n  DirectionalLight,\n  PerspectiveCamera,\n  PointLight,\n  Scene,\n  WebGLRenderer\n} from 'three'\n\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\n\nimport pointer from './pointer'\n\nexport default function (params) {\n  const options = {\n    el: null,\n    canvas: null,\n    eventsEl: null,\n    width: null,\n    height: null,\n    resize: true,\n    alpha: false,\n    antialias: false,\n    orbitControls: false,\n    init () {},\n    initCamera () {},\n    initScene () {},\n    afterResize () {},\n    beforeRender () {},\n    ...params\n  }\n\n  const three = {\n    renderer: null,\n    camera: null,\n    scene: null,\n    pointer: null,\n    width: 0,\n    height: 0,\n    wWidth: 0,\n    wHeight: 0,\n    clock: {\n      startTime: 0,\n      time: 0,\n      elapsed: 0\n    },\n    options\n  }\n\n  let render\n\n  let cameraCtrl\n\n  init()\n\n  return three\n\n  function init () {\n    let canvas\n    if (options.el) {\n      canvas = document.createElement('canvas')\n      options.el.appendChild(canvas)\n    } else if (options.canvas) {\n      canvas = options.canvas\n    } else {\n      throw new Error('Missing parameter : el or canvas is required')\n    }\n\n    options.init?.(three)\n\n    three.renderer = new WebGLRenderer({ canvas, alpha: options.alpha, antialias: options.antialias })\n    options.initRenderer?.(three)\n\n    three.camera = new PerspectiveCamera()\n    three.camera.position.z = 50\n    options.initCamera?.(three)\n\n    if (options.orbitControls) {\n      cameraCtrl = new OrbitControls(three.camera, options.eventsEl ?? three.renderer.domElement)\n      cameraCtrl.enableDamping = true\n      cameraCtrl.dampingFactor = 0.1\n      if (typeof options.orbitControls === 'object') {\n        Object.keys(options.orbitControls).forEach(key => {\n          cameraCtrl[key] = options.orbitControls[key]\n        })\n      }\n    }\n\n    resize()\n    if (options.resize && !options.width && !options.height) {\n      window.addEventListener('resize', resize)\n    }\n\n    three.scene = new Scene()\n    options.initScene?.(three)\n\n    initPointer()\n\n    render = options.render ? options.render : () => { three.renderer.render(three.scene, three.camera) }\n\n    requestAnimationFrame(timestamp => {\n      three.clock.startTime = three.clock.time = timestamp\n      requestAnimationFrame(animate)\n    })\n  }\n\n  function initPointer () {\n    const pointerOptions = {}\n    if (options.onPointerEnter) { pointerOptions.onEnter = options.onPointerEnter }\n    if (options.onPointerMove) { pointerOptions.onMove = options.onPointerMove }\n    if (options.onPointerMove) { pointerOptions.onLeave = options.onPointerLeave }\n    if (Object.keys(pointerOptions).length > 0) {\n      three.pointer = pointer({ domElement: options.eventsEl ?? (options.el ?? options.canvas), ...pointerOptions })\n    }\n  }\n\n  function animate (timestamp) {\n    const { clock } = three\n    clock.elapsed = timestamp - clock.time\n    clock.time = timestamp\n\n    options.beforeRender(three)\n\n    if (cameraCtrl) cameraCtrl.update()\n\n    render(three)\n    requestAnimationFrame(animate)\n  }\n\n  function resize () {\n    if (options.width && options.height) {\n      three.width = options.width\n      three.height = options.height\n    } else if (options.resize === 'window') {\n      three.width = window.innerWidth\n      three.height = window.innerHeight\n    } else {\n      const parent = three.renderer.domElement.parentElement\n      three.width = parent.clientWidth\n      three.height = parent.clientHeight\n    }\n\n    three.renderer.setSize(three.width, three.height)\n    three.camera.aspect = three.width / three.height\n    three.camera.updateProjectionMatrix()\n    if (three.camera instanceof PerspectiveCamera) {\n      const wsize = getCameraViewSize()\n      three.wWidth = wsize[0]; three.wHeight = wsize[1]\n    } else {\n      three.wWidth = three.camera.top - three.camera.bottom\n      three.wHeight = three.camera.right - three.camera.left\n    }\n    options.afterResize?.(three)\n  }\n\n  function getCameraViewSize () {\n    const vFOV = (three.camera.fov * Math.PI) / 180\n    const h = 2 * Math.tan(vFOV / 2) * Math.abs(three.camera.position.z)\n    const w = h * three.camera.aspect\n    return [w, h]\n  }\n}\n\nexport function commonConfig (params) {\n  const config = {}\n  const keys = ['el', 'canvas', 'eventsEl', 'width', 'height', 'resize', 'orbitControls']\n  keys.forEach(key => {\n    if (params[key] !== undefined) config[key] = params[key]\n  })\n  return config\n}\n\nexport function initLights (scene, lightsConfig) {\n  const lights = []\n  if (Array.isArray(lightsConfig) && lightsConfig.length > 0) {\n    let light\n    lightsConfig.forEach(lightConfig => {\n      switch (lightConfig.type) {\n        case 'ambient':\n          light = new AmbientLight(...lightConfig.params)\n          break\n        case 'directional':\n          light = new DirectionalLight(...lightConfig.params)\n          break\n        case 'point':\n          light = new PointLight(...lightConfig.params)\n          break\n        default:\n          console.error(`Unknown light type ${lightConfig.type}`)\n      }\n      if (light) {\n        if (typeof lightConfig.props === 'object') {\n          Object.keys(lightConfig.props).forEach(key => {\n            if (key === 'position') {\n              light.position.set(...lightConfig.props[key])\n            } else light[key] = lightConfig.props[key]\n          })\n        }\n        scene.add(light)\n        lights.push(light)\n      }\n    })\n  }\n  return lights\n}\n","import { Color, Mesh, OrthographicCamera, PlaneGeometry, ShaderMaterial, SplineCurve, Vector2, Vector3 } from 'three'\nimport three from '../../three'\n\nconst defaultConfig = {\n  shaderPoints: 8,\n  curvePoints: 80,\n  curveLerp: 0.75,\n  radius1: 3,\n  radius2: 5,\n  velocityTreshold: 10,\n  sleepRadiusX: 150,\n  sleepRadiusY: 150,\n  sleepTimeCoefX: 0.0025,\n  sleepTimeCoefY: 0.0025\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const points = new Array(config.curvePoints).fill(0).map(() => new Vector2())\n  const spline = new SplineCurve(points)\n\n  const velocity = new Vector3()\n  const velocityTarget = new Vector3()\n\n  const uRatio = { value: new Vector2() }\n  const uSize = { value: new Vector2() }\n  const uPoints = { value: new Array(config.shaderPoints).fill(0).map(() => new Vector2()) }\n  const uColor = { value: new Color(0xff00ff) }\n\n  let material\n  let plane\n  let hover = false\n\n  const threeConfig = {}\n  const keys = ['el', 'canvas', 'width', 'height', 'resize']\n  keys.forEach(key => {\n    if (params[key] !== undefined) threeConfig[key] = params[key]\n  })\n\n  three({\n    ...threeConfig,\n    antialias: false,\n    initCamera (three) {\n      three.camera = new OrthographicCamera()\n    },\n    initScene ({ scene }) {\n      const geometry = new PlaneGeometry(2, 2)\n      material = new ShaderMaterial({\n        uniforms: { uRatio, uSize, uPoints, uColor },\n        defines: {\n          SHADER_POINTS: config.shaderPoints\n        },\n        vertexShader: `\n          varying vec2 vUv;\n          void main() {\n            vUv = uv;\n            gl_Position = vec4(position, 1.0);\n          }\n        `,\n        fragmentShader: `\n          // https://www.shadertoy.com/view/wdy3DD\n          // https://www.shadertoy.com/view/MlKcDD\n          // Signed distance to a quadratic bezier\n          float sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C) {\n            vec2 a = B - A;\n            vec2 b = A - 2.0*B + C;\n            vec2 c = a * 2.0;\n            vec2 d = A - pos;\n            float kk = 1.0 / dot(b,b);\n            float kx = kk * dot(a,b);\n            float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n            float kz = kk * dot(d,a);\n            float res = 0.0;\n            float p = ky - kx*kx;\n            float p3 = p*p*p;\n            float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n            float h = q*q + 4.0*p3;\n            if(h >= 0.0){\n              h = sqrt(h);\n              vec2 x = (vec2(h, -h) - q) / 2.0;\n              vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n              float t = uv.x + uv.y - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 1 root\n              vec2 qos = d + (c + b*t)*t;\n              res = length(qos);\n            } else {\n              float z = sqrt(-p);\n              float v = acos( q/(p*z*2.0) ) / 3.0;\n              float m = cos(v);\n              float n = sin(v)*1.732050808;\n              vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n              t = clamp( t, 0.0, 1.0 );\n              // 3 roots\n              vec2 qos = d + (c + b*t.x)*t.x;\n              float dis = dot(qos,qos);\n              res = dis;\n              qos = d + (c + b*t.y)*t.y;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              qos = d + (c + b*t.z)*t.z;\n              dis = dot(qos,qos);\n              res = min(res,dis);\n              res = sqrt( res );\n            }\n            return res;\n          }\n\n          uniform vec2 uRatio;\n          uniform vec2 uSize;\n          uniform vec2 uPoints[SHADER_POINTS];\n          uniform vec3 uColor;\n          varying vec2 vUv;\n          void main() {\n            float intensity = 1.0;\n            float radius = 0.015;\n\n            vec2 pos = (vUv - 0.5) * uRatio;\n\n            vec2 c = (uPoints[0] + uPoints[1]) / 2.0;\n            vec2 c_prev;\n            float dist = 10000.0;\n            for(int i = 0; i < SHADER_POINTS - 1; i++){\n              c_prev = c;\n              c = (uPoints[i] + uPoints[i + 1]) / 2.0;\n              dist = min(dist, sdBezier(pos, c_prev, uPoints[i], c));\n            }\n            dist = max(0.0, dist);\n\n            float glow = pow(uSize.y / dist, intensity);\n            vec3 col = vec3(0.0);\n            col += 10.0 * vec3(smoothstep(uSize.x, 0.0, dist));\n            col += glow * uColor;\n\n            // Tone mapping\n            col = 1.0 - exp(-col);\n            col = pow(col, vec3(0.4545));\n  \n            gl_FragColor = vec4(col, 1.0);\n          }\n        `\n      })\n      plane = new Mesh(geometry, material)\n      scene.add(plane)\n    },\n    afterResize ({ width, height }) {\n      uSize.value.set(config.radius1, config.radius2)\n      if (width >= height) {\n        uRatio.value.set(1, height / width)\n        uSize.value.multiplyScalar(1 / width)\n      } else {\n        uRatio.value.set(width / height, 1)\n        uSize.value.multiplyScalar(1 / height)\n      }\n    },\n    beforeRender ({ clock, width, height, wWidth }) {\n      for (let i = 1; i < config.curvePoints; i++) {\n        points[i].lerp(points[i - 1], config.curveLerp)\n      }\n      for (let i = 0; i < config.shaderPoints; i++) {\n        spline.getPoint(i / (config.shaderPoints - 1), uPoints.value[i])\n      }\n\n      if (!hover) {\n        const t1 = clock.time * config.sleepTimeCoefX\n        const t2 = clock.time * config.sleepTimeCoefY\n        const cos = Math.cos(t1)\n        const sin = Math.sin(t2)\n        const r1 = config.sleepRadiusX * wWidth / width\n        const r2 = config.sleepRadiusY * wWidth / width\n        const x = r1 * cos\n        const y = r2 * sin\n        spline.points[0].set(x, y)\n        uColor.value.r = 0.5 + 0.5 * Math.cos(clock.time * 0.0015)\n        uColor.value.g = 0\n        uColor.value.b = 1 - uColor.value.r\n      } else {\n        uColor.value.r = velocity.z\n        uColor.value.g = 0\n        uColor.value.b = 1 - velocity.z\n        velocity.multiplyScalar(0.95)\n      }\n    },\n    onPointerMove ({ nPosition, delta }) {\n      hover = true\n      const x = (0.5 * nPosition.x) * uRatio.value.x\n      const y = (0.5 * nPosition.y) * uRatio.value.y\n      spline.points[0].set(x, y)\n\n      velocityTarget.x = Math.min(velocity.x + Math.abs(delta.x) / config.velocityTreshold, 1)\n      velocityTarget.y = Math.min(velocity.y + Math.abs(delta.y) / config.velocityTreshold, 1)\n      velocityTarget.z = Math.sqrt(velocityTarget.x * velocityTarget.x + velocityTarget.y * velocityTarget.y)\n      velocity.lerp(velocityTarget, 0.05)\n    },\n    onPointerLeave () {\n      hover = false\n    }\n  })\n\n  return { config }\n}\n","import { Color } from 'three'\r\n\r\nexport function colorScale (colors) {\r\n  let range = []\r\n  setColors(colors)\r\n\r\n  const dummy = new Color()\r\n\r\n  return { setColors, getColorAt }\r\n\r\n  function setColors (colors) {\r\n    range = []\r\n    colors.forEach(color => {\r\n      range.push(new Color(color))\r\n    })\r\n  }\r\n\r\n  function getColorAt (progress) {\r\n    const p = Math.max(0, Math.min(1, progress)) * (colors.length - 1)\r\n    const i1 = Math.floor(p)\r\n    const c1 = range[i1]\r\n    if (i1 === colors.length - 1) {\r\n      return c1.getHex()\r\n    }\r\n    const p1 = p - i1\r\n    const c2 = range[i1 + 1]\r\n\r\n    dummy.r = c1.r + p1 * (c2.r - c1.r)\r\n    dummy.g = c1.g + p1 * (c2.g - c1.g)\r\n    dummy.b = c1.b + p1 * (c2.b - c1.b)\r\n    return dummy.clone()\r\n  }\r\n}\r\n","//\r\n// psrdnoise3.glsl\r\n//\r\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\r\n// and Ian McEwan (ijm567@gmail.com)\r\n// Version 2021-12-02, published under the MIT license (see below)\r\n//\r\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the \"Software\"),\r\n// to deal in the Software without restriction, including without limitation\r\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n// and/or sell copies of the Software, and to permit persons to whom the\r\n// Software is furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n// DEALINGS IN THE SOFTWARE.\r\n//\r\n\r\n//\r\n// Periodic (tiling) 3-D simplex noise (tetrahedral lattice gradient noise)\r\n// with rotating gradients and analytic derivatives.\r\n//\r\n// This is (yet) another variation on simplex noise. Unlike previous\r\n// implementations, the grid is axis-aligned to permit rectangular tiling.\r\n// The noise pattern can be made to tile seamlessly to any integer periods\r\n// up to 289 units in the x, y and z directions. Specifying a longer\r\n// period than 289 will result in errors in the noise field.\r\n//\r\n// This particular version of 3-D noise also implements animation by rotating\r\n// the generating gradient at each lattice point around a pseudo-random axis.\r\n// The rotating gradients give the appearance of a swirling motion, and\r\n// can serve a similar purpose for animation as motion along the fourth\r\n// dimension in 4-D noise. \r\n//\r\n// The rotating gradients in conjunction with the built-in ability to\r\n// compute exact analytic derivatives allow for \"flow noise\" effects\r\n// as presented by Ken Perlin and Fabrice Neyret.\r\n//\r\n\r\n// Use Perlin's rotated grid instead of the new tiling grid?\r\n// Enabling this adds about 1% to the execution time and\r\n// requires all periods to be multiples of 3. Other\r\n// integer periods can be specified, but when not evenly\r\n// divisible by 3, the actual period will be 3 times longer.\r\n// Take care not to overstep the maximum allowed period (288).\r\n//#define PERLINGRID\r\n\r\n// Enable faster gradient rotations?\r\n// Enabling this saves about 10% on execution time,\r\n// but the function will not run faster for alpha = 0.\r\n//#define FASTROTATION\r\n\r\n\r\n// Permutation polynomial for the hash value\r\nvec4 permute(vec4 x) {\r\n     vec4 xm = mod(x, 289.0);\r\n     return mod(((xm*34.0)+10.0)*xm, 289.0);\r\n}\r\n\r\n//\r\n// 3-D tiling simplex noise with rotating gradients and first order\r\n// analytical derivatives.\r\n// \"vec3 x\" is the point (x,y,z) to evaluate\r\n// \"vec3 period\" is the desired periods along x,y,z, up to 289.\r\n// (If Perlin's grid is used, multiples of 3 up to 288 are allowed.)\r\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\r\n// The \"float\" return value is the noise value, and\r\n// the \"out vec3 gradient\" argument returns the x,y,z partial derivatives.\r\n//\r\n// The function executes 15-20% faster if alpha is constant == 0.0\r\n// across all fragments being executed in parallel.\r\n// (This speedup will not happen if FASTROTATION is enabled. Do not specify\r\n// FASTROTATION if you are not actually going to use the rotation.)\r\n//\r\n// Setting any period to 0.0 or a negative value will skip the periodic\r\n// wrap for that dimension. Setting all periods to 0.0 makes the function\r\n// execute 10-15% faster.\r\n//\r\n// Not using the return value for the gradient will make the compiler\r\n// eliminate the code for computing it. This speeds up the function by\r\n// around 10%.\r\n//\r\nfloat psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)\r\n{\r\n\r\n#ifndef PERLINGRID\r\n  // Transformation matrices for the axis-aligned simplex grid\r\n  const mat3 M = mat3(0.0, 1.0, 1.0,\r\n                      1.0, 0.0, 1.0,\r\n                      1.0, 1.0, 0.0);\r\n\r\n  const mat3 Mi = mat3(-0.5, 0.5, 0.5,\r\n                        0.5,-0.5, 0.5,\r\n                        0.5, 0.5,-0.5);\r\n#endif\r\n\r\n  vec3 uvw;\r\n\r\n  // Transform to simplex space (tetrahedral grid)\r\n#ifndef PERLINGRID\r\n  // Use matrix multiplication, let the compiler optimise\r\n  uvw = M * x;\r\n#else\r\n  // Optimised transformation to uvw (slightly faster than\r\n  // the equivalent matrix multiplication on most platforms)\r\n  uvw = x + dot(x, vec3(1.0/3.0));\r\n#endif\r\n\r\n  // Determine which simplex we're in, i0 is the \"base corner\"\r\n  vec3 i0 = floor(uvw);\r\n  vec3 f0 = fract(uvw); // coords within \"skewed cube\"\r\n\r\n  // To determine which simplex corners are closest, rank order the\r\n  // magnitudes of u,v,w, resolving ties in priority order u,v,w,\r\n  // and traverse the four corners from largest to smallest magnitude.\r\n  // o1, o2 are offsets in simplex space to the 2nd and 3rd corners.\r\n  vec3 g_ = step(f0.xyx, f0.yzz); // Makes comparison \"less-than\"\r\n  vec3 l_ = 1.0 - g_;             // complement is \"greater-or-equal\"\r\n  vec3 g = vec3(l_.z, g_.xy);\r\n  vec3 l = vec3(l_.xy, g_.z);\r\n  vec3 o1 = min( g, l );\r\n  vec3 o2 = max( g, l );\r\n\r\n  // Enumerate the remaining simplex corners\r\n  vec3 i1 = i0 + o1;\r\n  vec3 i2 = i0 + o2;\r\n  vec3 i3 = i0 + vec3(1.0);\r\n\r\n  vec3 v0, v1, v2, v3;\r\n\r\n  // Transform the corners back to texture space\r\n#ifndef PERLINGRID\r\n  v0 = Mi * i0;\r\n  v1 = Mi * i1;\r\n  v2 = Mi * i2;\r\n  v3 = Mi * i3;\r\n#else\r\n  // Optimised transformation (mostly slightly faster than a matrix)\r\n  v0 = i0 - dot(i0, vec3(1.0/6.0));\r\n  v1 = i1 - dot(i1, vec3(1.0/6.0));\r\n  v2 = i2 - dot(i2, vec3(1.0/6.0));\r\n  v3 = i3 - dot(i3, vec3(1.0/6.0));\r\n#endif\r\n\r\n  // Compute vectors to each of the simplex corners\r\n  vec3 x0 = x - v0;\r\n  vec3 x1 = x - v1;\r\n  vec3 x2 = x - v2;\r\n  vec3 x3 = x - v3;\r\n\r\n  if(any(greaterThan(period, vec3(0.0)))) {\r\n    // Wrap to periods and transform back to simplex space\r\n    vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);\r\n    vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);\r\n    vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);\r\n\t// Wrap to periods where specified\r\n\tif(period.x > 0.0) vx = mod(vx, period.x);\r\n\tif(period.y > 0.0) vy = mod(vy, period.y);\r\n\tif(period.z > 0.0) vz = mod(vz, period.z);\r\n    // Transform back\r\n#ifndef PERLINGRID\r\n    i0 = M * vec3(vx.x, vy.x, vz.x);\r\n    i1 = M * vec3(vx.y, vy.y, vz.y);\r\n    i2 = M * vec3(vx.z, vy.z, vz.z);\r\n    i3 = M * vec3(vx.w, vy.w, vz.w);\r\n#else\r\n    v0 = vec3(vx.x, vy.x, vz.x);\r\n    v1 = vec3(vx.y, vy.y, vz.y);\r\n    v2 = vec3(vx.z, vy.z, vz.z);\r\n    v3 = vec3(vx.w, vy.w, vz.w);\r\n    // Transform wrapped coordinates back to uvw\r\n    i0 = v0 + dot(v0, vec3(1.0/3.0));\r\n    i1 = v1 + dot(v1, vec3(1.0/3.0));\r\n    i2 = v2 + dot(v2, vec3(1.0/3.0));\r\n    i3 = v3 + dot(v3, vec3(1.0/3.0));\r\n#endif\r\n\t// Fix rounding errors\r\n    i0 = floor(i0 + 0.5);\r\n    i1 = floor(i1 + 0.5);\r\n    i2 = floor(i2 + 0.5);\r\n    i3 = floor(i3 + 0.5);\r\n  }\r\n\r\n  // Compute one pseudo-random hash value for each corner\r\n  vec4 hash = permute( permute( permute( \r\n              vec4(i0.z, i1.z, i2.z, i3.z ))\r\n            + vec4(i0.y, i1.y, i2.y, i3.y ))\r\n            + vec4(i0.x, i1.x, i2.x, i3.x ));\r\n\r\n  // Compute generating gradients from a Fibonacci spiral on the unit sphere\r\n  vec4 theta = hash * 3.883222077;  // 2*pi/golden ratio\r\n  vec4 sz    = hash * -0.006920415 + 0.996539792; // 1-(hash+0.5)*2/289\r\n  vec4 psi   = hash * 0.108705628 ; // 10*pi/289, chosen to avoid correlation\r\n\r\n  vec4 Ct = cos(theta);\r\n  vec4 St = sin(theta);\r\n  vec4 sz_prime = sqrt( 1.0 - sz*sz ); // s is a point on a unit fib-sphere\r\n\r\n  vec4 gx, gy, gz;\r\n\r\n  // Rotate gradients by angle alpha around a pseudo-random ortogonal axis\r\n#ifdef FASTROTATION\r\n  // Fast algorithm, but without dynamic shortcut for alpha = 0\r\n  vec4 qx = St;         // q' = norm ( cross(s, n) )  on the equator\r\n  vec4 qy = -Ct; \r\n  vec4 qz = vec4(0.0);\r\n\r\n  vec4 px =  sz * qy;   // p' = cross(q, s)\r\n  vec4 py = -sz * qx;\r\n  vec4 pz = sz_prime;\r\n\r\n  psi += alpha;         // psi and alpha in the same plane\r\n  vec4 Sa = sin(psi);\r\n  vec4 Ca = cos(psi);\r\n\r\n  gx = Ca * px + Sa * qx;\r\n  gy = Ca * py + Sa * qy;\r\n  gz = Ca * pz + Sa * qz;\r\n#else\r\n  // Slightly slower algorithm, but with g = s for alpha = 0, and a\r\n  // useful conditional speedup for alpha = 0 across all fragments\r\n  if(alpha != 0.0) {\r\n    vec4 Sp = sin(psi);          // q' from psi on equator\r\n    vec4 Cp = cos(psi);\r\n\r\n    vec4 px = Ct * sz_prime;     // px = sx\r\n    vec4 py = St * sz_prime;     // py = sy\r\n    vec4 pz = sz;\r\n\r\n    vec4 Ctp = St*Sp - Ct*Cp;    // q = (rotate( cross(s,n), dot(s,n))(q')\r\n    vec4 qx = mix( Ctp*St, Sp, sz);\r\n    vec4 qy = mix(-Ctp*Ct, Cp, sz);\r\n    vec4 qz = -(py*Cp + px*Sp);\r\n\r\n    vec4 Sa = vec4(sin(alpha));       // psi and alpha in different planes\r\n    vec4 Ca = vec4(cos(alpha));\r\n\r\n    gx = Ca * px + Sa * qx;\r\n    gy = Ca * py + Sa * qy;\r\n    gz = Ca * pz + Sa * qz;\r\n  }\r\n  else {\r\n    gx = Ct * sz_prime;  // alpha = 0, use s directly as gradient\r\n    gy = St * sz_prime;\r\n    gz = sz;  \r\n  }\r\n#endif\r\n\r\n  // Reorganize for dot products below\r\n  vec3 g0 = vec3(gx.x, gy.x, gz.x);\r\n  vec3 g1 = vec3(gx.y, gy.y, gz.y);\r\n  vec3 g2 = vec3(gx.z, gy.z, gz.z);\r\n  vec3 g3 = vec3(gx.w, gy.w, gz.w);\r\n\r\n  // Radial decay with distance from each simplex corner\r\n  vec4 w = 0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3));\r\n  w = max(w, 0.0);\r\n  vec4 w2 = w * w;\r\n  vec4 w3 = w2 * w;\r\n\r\n  // The value of the linear ramp from each of the corners\r\n  vec4 gdotx = vec4(dot(g0,x0), dot(g1,x1), dot(g2,x2), dot(g3,x3));\r\n\r\n  // Multiply by the radial decay and sum up the noise value\r\n  float n = dot(w3, gdotx);\r\n\r\n  // Compute the first order partial derivatives\r\n  vec4 dw = -6.0 * w2 * gdotx;\r\n  vec3 dn0 = w3.x * g0 + dw.x * x0;\r\n  vec3 dn1 = w3.y * g1 + dw.y * x1;\r\n  vec3 dn2 = w3.z * g2 + dw.z * x2;\r\n  vec3 dn3 = w3.w * g3 + dw.w * x3;\r\n  gradient = 39.5 * (dn0 + dn1 + dn2 + dn3);\r\n\r\n  // Scale the return value to fit nicely into the range [-1,1]\r\n  return 39.5 * n;\r\n}","import { AdditiveBlending, BufferAttribute, BufferGeometry, Color, HalfFloatType, MathUtils, Points, ShaderMaterial, Vector2 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\nimport three from '../../three'\nimport { colorScale } from '../../tools/color'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 256,\n  colors: [0x00ff00, 0x0000ff],\n  color: 0xff0000,\n  coordScale: 1.5,\n  noiseIntensity: 0.001,\n  noiseTimeCoef: 0.0001,\n  pointSize: 5,\n  pointDecay: 0.005,\n  sleepRadiusX: 250,\n  sleepRadiusY: 250,\n  sleepTimeCoefX: 0.001,\n  sleepTimeCoefY: 0.002\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTime = { value: 0 }\n  const uCoordScale = { value: config.coordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uPointSize = { value: config.pointSize }\n  const uPointDecay = { value: config.pointDecay }\n  const uColor = { value: new Color(config.color) }\n  const uMouse = { value: new Vector2() }\n  const uMouseDirection = { value: new Vector2() }\n  const uniforms = { uTime, uCoordScale, uNoiseIntensity, uPointSize, uPointDecay, uColor, uMouse, uMouseDirection }\n\n  let geometry, material, mesh\n\n  let hover = false\n  const mouseTarget = new Vector2()\n\n  three({\n    ...commonConfig(params),\n    antialias: false,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initScene ({ scene }) {\n      initParticles()\n      scene.add(mesh)\n    },\n    beforeRender ({ width, wWidth, wHeight, clock, pointer }) {\n      if (!hover) {\n        const t1 = clock.time * config.sleepTimeCoefX\n        const t2 = clock.time * config.sleepTimeCoefY\n        const cos = Math.cos(t1)\n        const sin = Math.sin(t2)\n        const r1 = config.sleepRadiusX * wWidth / width\n        const r2 = config.sleepRadiusY * wWidth / width\n        mouseTarget.x = r1 * cos\n        mouseTarget.y = r2 * sin\n      } else {\n        mouseTarget.x = pointer.nPosition.x * 0.5 * wWidth\n        mouseTarget.y = pointer.nPosition.y * 0.5 * wHeight\n      }\n      uMouse.value.lerp(mouseTarget, 0.05)\n\n      uTime.value = clock.time * config.noiseTimeCoef\n      gpu.compute()\n      material.uniforms.texturePosition.value = gpu.getCurrentRenderTarget(positionVariable).texture\n      material.uniforms.textureVelocity.value = gpu.getCurrentRenderTarget(velocityVariable).texture\n    },\n    onPointerMove ({ delta }) {\n      hover = true\n      uMouseDirection.value.copy(delta)\n    },\n    onPointerLeave () {\n      hover = false\n    }\n  })\n\n  return { config, uniforms }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uNoiseIntensity;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        if (pos.w < 0.0) {\n          vel.x = 0.0;\n          vel.y = 0.0;\n          vel.z = 0.0;\n        } else {\n          vec3 grad;\n          vec3 p = vec3(0.0);\n          float n = psrdnoise(pos.xyz * uCoordScale, p, uTime, grad);\n          vel.xyz += grad * uNoiseIntensity * pos.w;\n        }\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      uniform float uPointDecay;\n      uniform vec2 uMouse;\n      uniform vec2 uMouseDirection;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        if (pos.w < 0.0) { pos.w = vel.w; }\n        pos.w -= uPointDecay;\n        if (pos.w <= 0.0) {\n          pos.xy = uMouse.xy;\n          pos.z = 0.0;\n        } else {\n          pos.xyz += vel.xyz;\n        }\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(uniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      console.error(error)\n    }\n  }\n\n  /**\n   */\n  function initParticles () {\n    geometry = new BufferGeometry()\n    const positions = new Float32Array(COUNT * 3)\n    const uvs = new Float32Array(COUNT * 2)\n    const colors = new Float32Array(COUNT * 3)\n\n    for (let i = 0; i < COUNT * 3; i += 3) {\n      positions[i] = 0\n      positions[i + 1] = 0\n      positions[i + 2] = 0\n    }\n\n    let index = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        uvs[index++] = i / (WIDTH - 1)\n        uvs[index++] = j / (WIDTH - 1)\n      }\n    }\n\n    const cscale = colorScale(config.colors)\n    for (let i = 0; i < COUNT * 3; i += 3) {\n      const color = cscale.getColorAt(Math.random())\n      colors[i] = color.r\n      colors[i + 1] = color.g\n      colors[i + 2] = color.b\n    }\n\n    geometry.setAttribute('position', new BufferAttribute(positions, 3))\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2))\n    geometry.setAttribute('color', new BufferAttribute(colors, 3))\n\n    material = new ShaderMaterial({\n      blending: AdditiveBlending,\n      depthTest: false,\n      transparent: true,\n      vertexColors: true,\n      uniforms: {\n        texturePosition: { value: null },\n        textureVelocity: { value: null },\n        uPointSize,\n        uColor\n      },\n      vertexShader: `\n        uniform sampler2D texturePosition;\n        uniform sampler2D textureVelocity;\n        uniform float uPointSize;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          vCol = color;\n          vPos = texture2D(texturePosition, uv);\n          vVel = texture2D(textureVelocity, uv);\n          vec4 mvPosition = modelViewMatrix * vec4(vPos.xyz, 1.0);\n          // gl_PointSize = smoothstep(0.0, 2.0, vPos.w) * uPointSize;\n          gl_PointSize = vPos.w * (vVel.w + 0.5) * uPointSize;\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      `,\n      fragmentShader: `\n        uniform vec3 uColor;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying vec3 vCol;\n        void main() {\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n          // float a = smoothstep(0.0, 1.0, vPos.w);\n          gl_FragColor = vec4(mix(vCol, uColor, vPos.w), vPos.w);\n        }\n      `\n    })\n\n    mesh = new Points(geometry, material)\n    mesh.matrixAutoUpdate = false\n    mesh.updateMatrix()\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS(1)\n      posArray[k + 1] = rndFS(1)\n      posArray[k + 2] = -100000\n      posArray[k + 3] = rnd(0.1, 1)\n\n      velArray[k + 0] = 0 // rndFS(0.2)\n      velArray[k + 1] = 0 // rndFS(0.2)\n      velArray[k + 2] = 0 // rndFS(0.2)\n      velArray[k + 3] = rnd(0.1, 1)\n    }\n  }\n}\n\n/**\n */\nfunction commonConfig (params) {\n  const config = {}\n  const keys = ['el', 'canvas', 'width', 'height', 'resize']\n  keys.forEach(key => {\n    if (params[key] !== undefined) config[key] = params[key]\n  })\n  return config\n}\n","import { CanvasTexture } from 'three'\r\n\r\nconst defaultConfig = {\r\n  width: 256,\r\n  height: 256\r\n}\r\n\r\nexport default function (params) {\r\n  const config = { ...defaultConfig, ...params }\r\n\r\n  const canvas = document.createElement('canvas')\r\n  canvas.width = config.width\r\n  canvas.height = config.height\r\n\r\n  const ctx = canvas.getContext('2d')\r\n\r\n  const texture = new CanvasTexture(ctx.canvas)\r\n\r\n  return { canvas, ctx, texture }\r\n}\r\n","//\r\n// psrdnoise2.glsl\r\n//\r\n// Authors: Stefan Gustavson (stefan.gustavson@gmail.com)\r\n// and Ian McEwan (ijm567@gmail.com)\r\n// Version 2021-12-02, published under the MIT license (see below)\r\n//\r\n// Copyright (c) 2021 Stefan Gustavson and Ian McEwan.\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a\r\n// copy of this software and associated documentation files (the \"Software\"),\r\n// to deal in the Software without restriction, including without limitation\r\n// the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n// and/or sell copies of the Software, and to permit persons to whom the\r\n// Software is furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included\r\n// in all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n// DEALINGS IN THE SOFTWARE.\r\n//\r\n\r\n//\r\n// Periodic (tiling) 2-D simplex noise (hexagonal lattice gradient noise)\r\n// with rotating gradients and analytic derivatives.\r\n//\r\n// This is (yet) another variation on simplex noise. Unlike previous\r\n// implementations, the grid is axis-aligned and slightly stretched in\r\n// the y direction to permit rectangular tiling.\r\n// The noise pattern can be made to tile seamlessly to any integer period\r\n// in x and any even integer period in y. Odd periods may be specified\r\n// for y, but then the actual tiling period will be twice that number.\r\n//\r\n// The rotating gradients give the appearance of a swirling motion, and\r\n// can serve a similar purpose for animation as motion along z in 3-D\r\n// noise. The rotating gradients in conjunction with the analytic\r\n// derivatives allow for \"flow noise\" effects as presented by Ken\r\n// Perlin and Fabrice Neyret.\r\n//\r\n\r\n\r\n//\r\n// 2-D tiling simplex noise with rotating gradients and analytical derivative.\r\n// \"vec2 x\" is the point (x,y) to evaluate,\r\n// \"vec2 period\" is the desired periods along x and y, and\r\n// \"float alpha\" is the rotation (in radians) for the swirling gradients.\r\n// The \"float\" return value is the noise value, and\r\n// the \"out vec2 gradient\" argument returns the x,y partial derivatives.\r\n//\r\n// Setting either period to 0.0 or a negative value will skip the wrapping\r\n// along that dimension. Setting both periods to 0.0 makes the function\r\n// execute about 15% faster.\r\n//\r\n// Not using the return value for the gradient will make the compiler\r\n// eliminate the code for computing it. This speeds up the function\r\n// by 10-15%.\r\n//\r\n// The rotation by alpha uses one single addition. Unlike the 3-D version\r\n// of psrdnoise(), setting alpha == 0.0 gives no speedup.\r\n//\r\nfloat psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient) {\r\n\r\n\t// Transform to simplex space (axis-aligned hexagonal grid)\r\n\tvec2 uv = vec2(x.x + x.y*0.5, x.y);\r\n\r\n\t// Determine which simplex we're in, with i0 being the \"base\"\r\n\tvec2 i0 = floor(uv);\r\n\tvec2 f0 = fract(uv);\r\n\t// o1 is the offset in simplex space to the second corner\r\n\tfloat cmp = step(f0.y, f0.x);\r\n\tvec2 o1 = vec2(cmp, 1.0-cmp);\r\n\r\n\t// Enumerate the remaining simplex corners\r\n\tvec2 i1 = i0 + o1;\r\n\tvec2 i2 = i0 + vec2(1.0, 1.0);\r\n\r\n\t// Transform corners back to texture space\r\n\tvec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);\r\n\tvec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);\r\n\tvec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);\r\n\r\n\t// Compute vectors from v to each of the simplex corners\r\n\tvec2 x0 = x - v0;\r\n\tvec2 x1 = x - v1;\r\n\tvec2 x2 = x - v2;\r\n\r\n\tvec3 iu, iv;\r\n\tvec3 xw, yw;\r\n\r\n\t// Wrap to periods, if desired\r\n\tif(any(greaterThan(period, vec2(0.0)))) {\r\n\t\txw = vec3(v0.x, v1.x, v2.x);\r\n\t\tyw = vec3(v0.y, v1.y, v2.y);\r\n\t\tif(period.x > 0.0)\r\n\t\t\txw = mod(vec3(v0.x, v1.x, v2.x), period.x);\r\n\t\tif(period.y > 0.0)\r\n\t\t\tyw = mod(vec3(v0.y, v1.y, v2.y), period.y);\r\n\t\t// Transform back to simplex space and fix rounding errors\r\n\t\tiu = floor(xw + 0.5*yw + 0.5);\r\n\t\tiv = floor(yw + 0.5);\r\n\t} else { // Shortcut if neither x nor y periods are specified\r\n\t\tiu = vec3(i0.x, i1.x, i2.x);\r\n\t\tiv = vec3(i0.y, i1.y, i2.y);\r\n\t}\r\n\r\n\t// Compute one pseudo-random hash value for each corner\r\n\tvec3 hash = mod(iu, 289.0);\r\n\thash = mod((hash*51.0 + 2.0)*hash + iv, 289.0);\r\n\thash = mod((hash*34.0 + 10.0)*hash, 289.0);\r\n\r\n\t// Pick a pseudo-random angle and add the desired rotation\r\n\tvec3 psi = hash * 0.07482 + alpha;\r\n\tvec3 gx = cos(psi);\r\n\tvec3 gy = sin(psi);\r\n\r\n\t// Reorganize for dot products below\r\n\tvec2 g0 = vec2(gx.x,gy.x);\r\n\tvec2 g1 = vec2(gx.y,gy.y);\r\n\tvec2 g2 = vec2(gx.z,gy.z);\r\n\r\n\t// Radial decay with distance from each simplex corner\r\n\tvec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));\r\n\tw = max(w, 0.0);\r\n\tvec3 w2 = w * w;\r\n\tvec3 w4 = w2 * w2;\r\n\r\n\t// The value of the linear ramp from each of the corners\r\n\tvec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));\r\n\r\n\t// Multiply by the radial decay and sum up the noise value\r\n\tfloat n = dot(w4, gdotx);\r\n\r\n\t// Compute the first order partial derivatives\r\n\tvec3 w3 = w2 * w;\r\n\tvec3 dw = -8.0 * w3 * gdotx;\r\n\tvec2 dn0 = w4.x * g0 + dw.x * x0;\r\n\tvec2 dn1 = w4.y * g1 + dw.y * x1;\r\n\tvec2 dn2 = w4.z * g2 + dw.z * x2;\r\n\tgradient = 10.9 * (dn0 + dn1 + dn2);\r\n\r\n\t// Scale the return value to fit nicely into the range [-1,1]\r\n\treturn 10.9 * n;\r\n}","import { Mesh, PlaneGeometry, ShaderMaterial, Vector2 } from 'three'\nimport three from '../../three'\nimport useCanvasTexture from '../../tools/canvasTexture'\nimport psrdnoise from '../../glsl/psrdnoise2.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst defaultConfig = {\n  colors: [0xffffff, 0x000000],\n  minStroke: 5,\n  maxStroke: 5,\n  timeCoef: 0.0005,\n  coordScale: 2,\n  displacementScale: 0.002,\n  mouseScale: 0.25,\n  mouseLerp: 0.025\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const canvasTexture = useCanvasTexture({ width: 1, height: 4096 })\n  drawTexture()\n\n  const uniforms = {\n    uMap: { value: canvasTexture.texture },\n    uTime: { value: 0 },\n    uCoordScale: { value: config.coordScale },\n    uDisplacementScale: { value: config.displacementScale },\n    uMouse: { value: new Vector2() }\n  }\n\n  const geometry = new PlaneGeometry()\n\n  const material = new ShaderMaterial({\n    uniforms,\n    vertexShader: `\n      varying vec2 vUv;\n      void main() {\n        vUv = uv;\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n      }\n    `,\n    fragmentShader: `\n      uniform sampler2D uMap;\n      uniform float uTime;\n      uniform float uCoordScale;\n      uniform float uDisplacementScale;\n      uniform vec2 uMouse;\n      varying vec2 vUv;\n      ${psrdnoise}\n      void main() {\n        vec2 p = vec2(0.0);\n        vec2 grad;\n        float n = psrdnoise(vUv * uCoordScale + uMouse, p, uTime, grad);\n        // grad *= uCoordScale;\n        vec2 uv = vUv + uDisplacementScale * grad;\n        gl_FragColor = texture2D(uMap, uv.yx);\n      }\n    `\n  })\n\n  const mesh = new Mesh(geometry, material)\n\n  const mouseTarget = new Vector2()\n\n  const threeConfig = {}\n  const keys = ['el', 'canvas', 'width', 'height', 'resize']\n  keys.forEach(key => {\n    if (params[key] !== undefined) threeConfig[key] = params[key]\n  })\n\n  three({\n    ...threeConfig,\n    antialias: true,\n    initScene ({ camera, scene, wWidth, wHeight }) {\n      mesh.scale.set(wWidth * 2, wHeight * 2, 1)\n      scene.add(mesh)\n\n      camera.position.set(0, -30, 7)\n      camera.lookAt(0, -19, 0)\n    },\n    beforeRender ({ clock }) {\n      uniforms.uTime.value = clock.time * config.timeCoef\n      uniforms.uMouse.value.lerp(mouseTarget, config.mouseLerp)\n    },\n    onPointerMove ({ nPosition }) {\n      mouseTarget.set(-nPosition.x, nPosition.y).multiplyScalar(config.mouseScale)\n    },\n    onPointerLeave () {\n      mouseTarget.set(0, 0)\n    }\n  })\n\n  return { config, uniforms, drawTexture }\n\n  function drawTexture () {\n    const ctx = canvasTexture.ctx\n    ctx.lineWidth = 0\n\n    const { width, height } = canvasTexture.canvas\n    const cscale = colorScale(config.colors)\n\n    let y = 0\n    let dy\n    while (y < height) {\n      dy = config.minStroke + Math.random() * (config.maxStroke - config.minStroke)\n\n      // ctx.strokeStyle = cscale.getColorAt(Math.random()).getStyle()\n      // ctx.lineWidth = dy + 1\n      // ctx.beginPath()\n      // ctx.moveTo(0, y + dy / 2)\n      // ctx.lineTo(width, y + dy / 2)\n      // ctx.stroke()\n      // ctx.closePath()\n\n      ctx.fillStyle = cscale.getColorAt(Math.random()).getStyle()\n      ctx.beginPath()\n      ctx.rect(0, y - 1, width, dy + 1)\n      ctx.fill()\n      ctx.closePath()\n\n      y += dy\n    }\n\n    canvasTexture.texture.needsUpdate = true\n  }\n}\n","import { Color, DoubleSide, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, PlaneGeometry, TextureLoader, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 64,\n  background: 0xffffff,\n  material: 'basic',\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [0xffffff, 0xffffff],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.5] },\n    { type: 'directional', params: [0xffffff, 1], props: { position: [0, 10, 0] } }\n  ],\n  wingsScale: [1, 1, 1],\n  wingsWidthSegments: 8,\n  wingsHeightSegments: 8,\n  wingsSpeed: 0.75,\n  wingsDisplacementScale: 1.25,\n  noiseCoordScale: 0.01,\n  noiseTimeCoef: 0.0005,\n  noiseIntensity: 0.0025,\n  attractionRadius1: 100,\n  attractionRadius2: 150,\n  maxVelocity: 0.1\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  if (!['basic', 'phong', 'standard'].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`)\n  }\n\n  if (!Number.isInteger(config.wingsWidthSegments) || config.wingsWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid wingsWidthSegments ${config.wingsWidthSegments}`)\n  }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uWingsScale = { value: new Vector3(...config.wingsScale) }\n  const uWingsSpeed = { value: config.wingsSpeed }\n  const uWingsDisplacementScale = { value: config.wingsDisplacementScale }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uWingsScale, uWingsSpeed, uWingsDisplacementScale }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let geometry, material, iMesh\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera ({ camera }) {\n      camera.position.set(0, 50, 70)\n    },\n    initScene ({ scene }) {\n      initScene(scene)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uWingsSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uWingsSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n    }\n\n    initLights(scene, config.lights)\n\n    geometry = new PlaneGeometry(2, 2, config.wingsWidthSegments, config.wingsHeightSegments).rotateX(Math.PI / 2)\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    const mapIndexes = new Float32Array(COUNT)\n    let i1 = 0\n    let i2 = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1)\n        gpuUvs[i1++] = j / (WIDTH - 1)\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n    geometry.setAttribute('mapIndex', new InstancedBufferAttribute(mapIndexes, 1))\n\n    const materialParams = { side: DoubleSide, ...config.materialParams }\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture)\n    }\n\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== 'basic',\n        WINGS_WIDTH_SEGMENTS: config.wingsWidthSegments,\n        WINGS_HEIGHT_SEGMENTS: config.wingsHeightSegments,\n        WINGS_DX: (2.0 / config.wingsWidthSegments).toFixed(10),\n        WINGS_DZ: (2.0 / config.wingsHeightSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      }\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key]\n      })\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uWingsScale;\n        uniform float uWingsDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n\n        mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n          vec3 z = target - origin;\n          if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n          z = normalize(z);\n          vec3 x = cross(up, z);\n          if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n            if (abs(up.z) == 1.0) { z.x += 0.0001; }\n            else { z.z += 0.0001; }\n            x = cross(up, z);\n          }\n          x = normalize(x);\n          vec3 y = cross(z, x);\n          return mat3(x, y, z);\n        }\n\n        mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n          return mat4(\n            rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n            rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n            rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n            pos.x, pos.y, pos.z, 1.0\n          );\n        }\n      ` + shader.vertexShader\n      shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <normal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uWingsScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dx = abs(transformed.x);\n        if (dx > 0.0) {\n          float sdx = smoothstep(0.0, 1.0 + WINGS_DX, dx);\n          #if WINGS_HEIGHT_SEGMENTS > 1\n            float dz = transformed.z + 1.0;\n            float sdz = smoothstep(0.0, 2.0 + WINGS_DZ, dz);\n            transformed.y = sin(vVel.w - sdx + sdz) * sdx * uWingsDisplacementScale;\n          #else\n            transformed.y = sin(vVel.w - sdx) * sdx * uWingsDisplacementScale;\n          #endif\n\n          #ifdef COMPUTE_NORMALS\n            #if WINGS_HEIGHT_SEGMENTS > 1\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float sdz1 = smoothstep(0.0, 2.0 + WINGS_DZ, dz + WINGS_DZ);\n              float dvy1 = sin(vVel.w - sdx + sdz1) * sdx * uWingsDisplacementScale - transformed.y;\n              float dvy2 = sin(vVel.w - sdx1 + sdz) * sdx1 * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, dvy1, s * WINGS_DZ);\n              vec3 v2 = vec3(s * WINGS_DX, dvy2, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #else\n              float s = sign(transformed.x);\n              float sdx1 = smoothstep(0.0, 1.0 + WINGS_DX, dx + WINGS_DX);\n              float dvy1 = sin(vVel.w - sdx1) * sdx * uWingsDisplacementScale - transformed.y;\n              vec3 v1 = vec3(0.0, 0.0, s);\n              vec3 v2 = vec3(s * WINGS_DX, dvy1, 0.0);\n              transformedNormal = -normalize(cross(v1, v2));\n            #endif  \n          #endif\n        }\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `)\n\n      shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `)\n\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader\n      shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `)\n    }\n\n    switch (config.material) {\n      case 'standard' :\n        material = new MeshStandardMaterial(materialParams)\n        break\n      case 'phong' :\n        material = new MeshPhongMaterial(materialParams)\n        break\n      default :\n        material = new MeshBasicMaterial(materialParams)\n    }\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS(150)\n      posArray[k + 1] = rndFS(150)\n      posArray[k + 2] = rndFS(150)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      velArray[k + 0] = rndFS(0.5)\n      velArray[k + 1] = rndFS(0.5)\n      velArray[k + 2] = rndFS(0.5)\n      velArray[k + 3] = 0\n    }\n  }\n}\n","import { BoxGeometry, BufferGeometry, CapsuleGeometry, Color, ConeGeometry, DoubleSide, Float32BufferAttribute, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshStandardMaterial, OctahedronGeometry, SphereGeometry, Vector2, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\nimport { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js'\nimport { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js'\nimport { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 256,\n  bloomStrength: 1.5,\n  bloomRadius: 0.5,\n  bloomThreshold: 0.25,\n  colors: [Math.random() * 0xffffff, Math.random() * 0xffffff, Math.random() * 0xffffff],\n  geometry: 'custom',\n  geometryScale: [1, 1, 1],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.5] },\n    { type: 'point', params: [0xffffff, 1], props: { position: [0, 0, 0] } },\n    { type: 'point', params: [0xff9060, 0.75], props: { position: [0, -100, -100] } },\n    { type: 'point', params: [0x6090ff, 0.75], props: { position: [0, 100, 100] } }\n  ],\n  materialParams: {},\n  noiseCoordScale: 0.01,\n  noiseIntensity: 0.0025,\n  noiseTimeCoef: 0.0004,\n  attractionRadius1: 150,\n  attractionRadius2: 250,\n  maxVelocity: 0.25\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uScale = { value: new Vector3(...config.geometryScale) }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uMouse = { value: new Vector3() }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uScale, uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uMouse }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let effectComposer\n  let renderPass, bloomPass\n\n  let camera\n  let geometry, material, iMesh\n\n  // const mousePlane = new Plane(new Vector3(0, 0, 1), 0)\n  // const mousePosition = new Vector3()\n  // const raycaster = new Raycaster()\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: false,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera (three) {\n      camera = three.camera\n      camera.position.z = 70\n    },\n    initScene ({ renderer, width, height, camera, scene }) {\n      initScene(scene)\n\n      renderPass = new RenderPass(scene, camera)\n      bloomPass = new UnrealBloomPass(new Vector2(width, height), config.bloomStrength, config.bloomRadius, config.bloomThreshold)\n      effectComposer = new EffectComposer(renderer)\n      effectComposer.addPass(renderPass)\n      effectComposer.addPass(bloomPass)\n    },\n    afterResize ({ width, height }) {\n      if (effectComposer) effectComposer.setSize(width, height)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n      // uMouse.value.copy(mousePosition)\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    },\n    render () {\n      effectComposer.render()\n    }\n    // onPointerMove ({ nPosition }) {\n    //   raycaster.setFromCamera(nPosition, camera)\n    //   camera.getWorldDirection(mousePlane.normal)\n    //   raycaster.ray.intersectPlane(mousePlane, mousePosition)\n    // },\n    // onPointerLeave () {\n    //   mousePosition.set(0, 0, 0)\n    // }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        vel.xyz += (pos.w * 0.75) * grad * uNoiseIntensity;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform vec3 uMouse;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n    }\n\n    initLights(scene, config.lights)\n\n    switch (config.geometry) {\n      case 'box' :\n        geometry = new BoxGeometry()\n        break\n      case 'capsule' :\n        geometry = new CapsuleGeometry(0.2, 1, 4, 8).rotateX(Math.PI / 2)\n        break\n      case 'cone' :\n        geometry = new ConeGeometry(0.4, 2, 6).rotateX(Math.PI / 2)\n        break\n      case 'octahedron':\n        geometry = new OctahedronGeometry(1, 0).rotateX(Math.PI / 2)\n        break\n      case 'sphere' :\n        geometry = new SphereGeometry(0.5, 8, 8)\n        break\n      default:\n        geometry = customGeometry(1)\n    }\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    let index = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[index++] = i / (WIDTH - 1)\n        gpuUvs[index++] = j / (WIDTH - 1)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n\n    material = new MeshStandardMaterial({\n      metalness: 0.75,\n      roughness: 0.25,\n      side: DoubleSide,\n      ...config.materialParams,\n      onBeforeCompile: shader => {\n        Object.keys(uniforms).forEach(key => {\n          shader.uniforms[key] = uniforms[key]\n        })\n        shader.vertexShader = `\n          uniform sampler2D uTexturePosition;\n          uniform sampler2D uOldTexturePosition;\n          uniform sampler2D uTextureVelocity;\n          uniform vec3 uScale;\n          attribute vec2 gpuUv;\n          varying vec4 vPos;\n          varying vec4 vVel;\n\n          mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n            vec3 z = target - origin;\n            if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n            z = normalize(z);\n            vec3 x = cross(up, z);\n            if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n              if (abs(up.z) == 1.0) { z.x += 0.0001; }\n              else { z.z += 0.0001; }\n              x = cross(up, z);\n            }\n            x = normalize(x);\n            vec3 y = cross(z, x);\n            return mat3(x, y, z);\n          }\n\n          mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n            return mat4(\n              rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n              rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n              rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n              pos.x, pos.y, pos.z, 1.0\n            );\n          }\n        ` + shader.vertexShader\n        shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', `\n          vPos = texture2D(uTexturePosition, gpuUv);\n          vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n          vVel = texture2D(uTextureVelocity, gpuUv);\n\n          mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n          mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uScale);\n\n          vec3 transformedNormal = objectNormal;\n          mat3 m = mat3(im);\n          transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n          transformedNormal = m * transformedNormal;\n          transformedNormal = normalMatrix * transformedNormal;\n        `)\n        shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n          vec4 mvPosition = modelViewMatrix * im * vec4(transformed, 1.0);\n          gl_Position = projectionMatrix * mvPosition;\n        `)\n      }\n    })\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  /**\n   */\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const dummy = new Vector3()\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(rndFS(config.attractionRadius1 * 2))\n      dummy.toArray(posArray, k)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      // dummy.set(rndFS(1), rndFS(1), rndFS(1)).normalize().multiplyScalar(0.1)\n      dummy.set(0, 0, 0)\n      dummy.toArray(velArray, k)\n      velArray[k + 3] = 0\n    }\n  }\n}\n\nfunction customGeometry (size) {\n  const vertices = [\n    { p: [size * 0.5, 0, -size], n: [0, 1, 0] },\n    { p: [-size * 0.5, 0, -size], n: [0, 1, 0] },\n    { p: [0, 0, size], n: [0, 1, 0] },\n    { p: [0, -size * 0.5, -size], n: [1, 0, 0] },\n    { p: [0, size * 0.5, -size], n: [1, 0, 0] },\n    { p: [0, 0, size], n: [1, 0, 0] }\n  ]\n\n  const indexes = [0, 1, 2, 3, 4, 5]\n\n  const positions = []\n  const normals = []\n  for (const vertex of vertices) {\n    positions.push(...vertex.p)\n    normals.push(...vertex.n)\n  }\n\n  const geometry = new BufferGeometry()\n  geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))\n  geometry.setAttribute('normal', new Float32BufferAttribute(normals, 3))\n  geometry.setIndex(indexes)\n\n  return geometry\n}\n","import { Color, DoubleSide, FogExp2, HalfFloatType, InstancedBufferAttribute, InstancedMesh, MathUtils, MeshBasicMaterial, MeshPhongMaterial, MeshStandardMaterial, PlaneGeometry, TextureLoader, Vector3 } from 'three'\nimport { GPUComputationRenderer } from 'three/examples/jsm/misc/GPUComputationRenderer.js'\n\nimport three, { commonConfig, initLights } from '../../three'\nimport psrdnoise from '../../glsl/psrdnoise3.glsl'\nimport { colorScale } from '../../tools/color'\n\nconst { randFloat: rnd, randFloatSpread: rndFS } = MathUtils\n\nconst defaultConfig = {\n  gpgpuSize: 64,\n  background: 0xffffff,\n  material: 'basic',\n  materialParams: {},\n  texture: null,\n  textureCount: 1,\n  colors: [0xffffff, 0xffffff],\n  lights: [\n    { type: 'ambient', params: [0xffffff, 0.5] },\n    { type: 'directional', params: [0xffffff, 0.5], props: { position: [20, 50, 100] } }\n  ],\n  fogDensity: 0.01,\n  fishScale: [1, 1, 1],\n  fishWidthSegments: 8,\n  fishSpeed: 1.5,\n  fishDisplacementScale: 0.2,\n  noiseCoordScale: 0.02,\n  noiseTimeCoef: 0.0005,\n  noiseIntensity: 0.0025,\n  attractionRadius1: 50,\n  attractionRadius2: 100,\n  maxVelocity: 0.1\n}\n\nexport default function (params) {\n  const config = { ...defaultConfig, ...params }\n\n  if (!['basic', 'phong', 'standard'].includes(config.material)) {\n    throw new Error(`Invalid material ${config.material}`)\n  }\n\n  if (!Number.isInteger(config.fishWidthSegments) || config.fishWidthSegments % 2 !== 0) {\n    throw new Error(`Invalid fishWidthSegments ${config.fishWidthSegments}`)\n  }\n\n  const WIDTH = config.gpgpuSize\n  const COUNT = WIDTH * WIDTH\n\n  let gpu\n  let dtPosition, dtVelocity\n  let velocityVariable, positionVariable\n\n  const uTexturePosition = { value: null }\n  const uOldTexturePosition = { value: null }\n  const uTextureVelocity = { value: null }\n  const uTime = { value: 0 }\n  const uNoiseCoordScale = { value: config.noiseCoordScale }\n  const uNoiseIntensity = { value: config.noiseIntensity }\n  const uMaxVelocity = { value: config.maxVelocity }\n  const uAttractionRadius1 = { value: config.attractionRadius1 }\n  const uAttractionRadius2 = { value: config.attractionRadius2 }\n  const uFishScale = { value: new Vector3(...config.fishScale) }\n  const uFishSpeed = { value: config.fishSpeed }\n  const uFishDisplacementScale = { value: config.fishDisplacementScale }\n\n  const gpuTexturesUniforms = { uTexturePosition, uOldTexturePosition, uTextureVelocity }\n  const commonUniforms = { uTime, uNoiseCoordScale, uNoiseIntensity, uMaxVelocity, uAttractionRadius1, uAttractionRadius2, uFishScale, uFishSpeed, uFishDisplacementScale }\n  const uniforms = { ...gpuTexturesUniforms, ...commonUniforms }\n\n  let geometry, material, iMesh\n\n  const _three = three({\n    ...commonConfig(params),\n    antialias: true,\n    orbitControls: true,\n    initRenderer ({ renderer }) {\n      initGPU(renderer)\n    },\n    initCamera ({ camera }) {\n      camera.position.set(0, 20, 70)\n    },\n    initScene ({ scene }) {\n      initScene(scene)\n    },\n    beforeRender ({ clock }) {\n      uTime.value = clock.time * config.noiseTimeCoef\n\n      gpu.compute()\n      uTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex].texture\n      uOldTexturePosition.value = positionVariable.renderTargets[gpu.currentTextureIndex === 0 ? 1 : 0].texture\n      uTextureVelocity.value = velocityVariable.renderTargets[gpu.currentTextureIndex].texture\n    }\n  })\n\n  return { three: _three, config, uniforms, setColors }\n\n  /**\n   */\n  function initGPU (renderer) {\n    gpu = new GPUComputationRenderer(WIDTH, WIDTH, renderer)\n    if (!renderer.capabilities.isWebGL2) {\n      gpu.setDataType(HalfFloatType)\n    }\n\n    dtPosition = gpu.createTexture()\n    dtVelocity = gpu.createTexture()\n    initTextures(dtPosition, dtVelocity)\n\n    velocityVariable = gpu.addVariable('textureVelocity', `\n      ${psrdnoise}\n      uniform float uTime;\n      uniform float uNoiseCoordScale;\n      uniform float uNoiseIntensity;\n      uniform float uMaxVelocity;\n      uniform float uAttractionRadius1;\n      uniform float uAttractionRadius2;\n      uniform float uFishSpeed;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n\n        vec3 grad;\n        float n = psrdnoise(pos.xyz * uNoiseCoordScale, vec3(0), uTime, grad);\n        grad = grad * uNoiseIntensity;\n        vel.xyz = vel.xyz + (pos.w * 0.75) * grad;\n\n        vec3 dv = -pos.xyz;\n        float coef = smoothstep(uAttractionRadius1, uAttractionRadius2, length(dv));\n        vel.xyz = vel.xyz + pos.w * coef * normalize(dv);\n        vel.xyz = clamp(vel.xyz, -uMaxVelocity, uMaxVelocity);\n\n        vel.w = mod(vel.w + length(vel.xyz) * (0.5 + pos.w) * uFishSpeed, 6.2831853071);\n        gl_FragColor = vel;\n      }\n    `, dtVelocity)\n\n    positionVariable = gpu.addVariable('texturePosition', `\n      ${psrdnoise}\n      uniform float uTime;\n      void main() {\n        vec2 uv = gl_FragCoord.xy / resolution.xy;\n        vec4 pos = texture2D(texturePosition, uv);\n        vec4 vel = texture2D(textureVelocity, uv);\n        pos.xyz += vel.xyz;\n        gl_FragColor = pos;\n      }\n    `, dtPosition)\n\n    gpu.setVariableDependencies(velocityVariable, [positionVariable, velocityVariable])\n    gpu.setVariableDependencies(positionVariable, [positionVariable, velocityVariable])\n\n    Object.keys(commonUniforms).forEach(key => {\n      velocityVariable.material.uniforms[key] = uniforms[key]\n      positionVariable.material.uniforms[key] = uniforms[key]\n    })\n\n    const error = gpu.init()\n    if (error !== null) {\n      throw new Error(error)\n    }\n  }\n\n  /**\n   */\n  function initScene (scene) {\n    if (config.background !== undefined) {\n      scene.background = new Color(config.background)\n      if (config.fogDensity) scene.fog = new FogExp2(config.background, config.fogDensity)\n    }\n\n    initLights(scene, config.lights)\n\n    geometry = new PlaneGeometry(2, 1, config.fishWidthSegments, 1).rotateY(Math.PI / 2)\n\n    const gpuUvs = new Float32Array(COUNT * 2)\n    const mapIndexes = new Float32Array(COUNT)\n    let i1 = 0\n    let i2 = 0\n    for (let j = 0; j < WIDTH; j++) {\n      for (let i = 0; i < WIDTH; i++) {\n        gpuUvs[i1++] = i / (WIDTH - 1)\n        gpuUvs[i1++] = j / (WIDTH - 1)\n        mapIndexes[i2++] = Math.floor(Math.random() * config.textureCount)\n      }\n    }\n    geometry.setAttribute('gpuUv', new InstancedBufferAttribute(gpuUvs, 2))\n    geometry.setAttribute('mapIndex', new InstancedBufferAttribute(mapIndexes, 1))\n\n    const materialParams = { side: DoubleSide, ...config.materialParams }\n    if (config.texture) {\n      materialParams.map = new TextureLoader().load(config.texture)\n    }\n\n    materialParams.onBeforeCompile = shader => {\n      shader.defines = {\n        COMPUTE_NORMALS: config.material !== 'basic',\n        FISH_DZ: (2.0 / config.fishWidthSegments).toFixed(10),\n        TEXTURE_COUNT: config.textureCount.toFixed(10)\n      }\n      Object.keys(uniforms).forEach(key => {\n        shader.uniforms[key] = uniforms[key]\n      })\n      shader.vertexShader = `\n        uniform sampler2D uTexturePosition;\n        uniform sampler2D uOldTexturePosition;\n        uniform sampler2D uTextureVelocity;\n        uniform vec3 uFishScale;\n        uniform float uFishDisplacementScale;\n        attribute vec2 gpuUv;\n        attribute float mapIndex;\n        varying vec4 vPos;\n        varying vec4 vVel;\n        varying float vMapIndex;\n\n        mat3 lookAt(vec3 origin, vec3 target, vec3 up) {\n          vec3 z = target - origin;\n          if (z.x * z.x + z.y * z.y + z.z * z.z == 0.0) { z.z = 1.0; }\n          z = normalize(z);\n          vec3 x = cross(up, z);\n          if (x.x * x.x + x.y * x.y + x.z * x.z == 0.0) {\n            if (abs(up.z) == 1.0) { z.x += 0.0001; }\n            else { z.z += 0.0001; }\n            x = cross(up, z);\n          }\n          x = normalize(x);\n          vec3 y = cross(z, x);\n          return mat3(x, y, z);\n        }\n\n        mat4 iMatrix(vec3 pos, mat3 rmat, vec3 scale) {\n          return mat4(\n            rmat[0][0] * scale.x, rmat[0][1] * scale.x, rmat[0][2] * scale.x, 0.0,\n            rmat[1][0] * scale.y, rmat[1][1] * scale.y, rmat[1][2] * scale.y, 0.0,\n            rmat[2][0] * scale.z, rmat[2][1] * scale.z, rmat[2][2] * scale.z, 0.0,\n            pos.x, pos.y, pos.z, 1.0\n          );\n        }\n      ` + shader.vertexShader\n      shader.vertexShader = shader.vertexShader.replace('#include <defaultnormal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <normal_vertex>', '')\n      shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `\n        vPos = texture2D(uTexturePosition, gpuUv);\n        vec4 oldPos = texture2D(uOldTexturePosition, gpuUv);\n        vVel = texture2D(uTextureVelocity, gpuUv);\n        vMapIndex = float(mapIndex);\n\n        mat3 rmat = lookAt(oldPos.xyz, vPos.xyz, vec3(0, 1, 0));\n        mat4 im = iMatrix(vPos.xyz, rmat, (0.5 + vPos.w) * uFishScale);\n\n        vec3 transformed = vec3(position);\n\n        #ifdef COMPUTE_NORMALS\n          vec3 transformedNormal = objectNormal; \n        #endif\n\n        float dz = transformed.z + 1.0;\n        float sdz = smoothstep(2.0, 0.0, dz);\n        transformed.x += sin(vVel.w + dz * PI * 1.5) * sdz * uFishDisplacementScale;\n\n        #ifdef COMPUTE_NORMALS\n          float dz1 = dz - 0.2;\n          float sdz1 = smoothstep(2.0, 0.0, dz1);\n          float dx1 = sin(vVel.w + dz1 * PI * 1.5) * sdz1 * uFishDisplacementScale - transformed.x;\n          vec3 v1 = vec3(dx1, 0.0, -FISH_DZ);\n          vec3 v2 = vec3(0.0, 1.0, 0.0);\n          transformedNormal = normalize(cross(v1, v2));\n        #endif\n\n        #ifdef COMPUTE_NORMALS\n          #ifdef USE_INSTANCING\n            mat3 m = mat3( im );\n            transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n            transformedNormal = m * transformedNormal;\n          #endif\n          transformedNormal = normalMatrix * transformedNormal;\n          #ifdef FLIP_SIDED\n            transformedNormal = - transformedNormal;\n          #endif\n          #ifdef USE_TANGENT\n            vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n            #ifdef FLIP_SIDED\n              transformedTangent = - transformedTangent;\n            #endif\n          #endif\n          #ifndef FLAT_SHADED\n            vNormal = normalize( transformedNormal );\n            #ifdef USE_TANGENT\n              vTangent = normalize( transformedTangent );\n              vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n            #endif\n          #endif\n        #endif\n      `)\n\n      shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `\n        vec4 mvPosition = vec4( transformed, 1.0 );\n        #ifdef USE_INSTANCING\n          mvPosition = im * mvPosition;\n        #endif\n        mvPosition = modelViewMatrix * mvPosition;\n        gl_Position = projectionMatrix * mvPosition;\n      `)\n\n      shader.fragmentShader = `\n        varying float vMapIndex;\n      ` + shader.fragmentShader\n      shader.fragmentShader = shader.fragmentShader.replace('#include <map_fragment>', `\n        #ifdef USE_MAP\n          vec2 uv = vUv;\n          uv.x = (vMapIndex + vUv.x) / TEXTURE_COUNT;\n          vec4 sampledDiffuseColor = texture2D(map, uv);\n          diffuseColor *= sampledDiffuseColor;\n        #endif\n      `)\n    }\n\n    switch (config.material) {\n      case 'standard' :\n        material = new MeshStandardMaterial(materialParams)\n        break\n      case 'phong' :\n        material = new MeshPhongMaterial(materialParams)\n        break\n      default :\n        material = new MeshBasicMaterial(materialParams)\n    }\n\n    iMesh = new InstancedMesh(geometry, material, COUNT)\n    setColors(config.colors)\n    scene.add(iMesh)\n  }\n\n  function setColors (colors) {\n    if (Array.isArray(colors) && colors.length > 1) {\n      const cscale = colorScale(colors)\n      for (let i = 0; i < COUNT; i++) {\n        iMesh.setColorAt(i, cscale.getColorAt(i / COUNT))\n      }\n      iMesh.instanceColor.needsUpdate = true\n    }\n  }\n\n  /**\n   */\n  function initTextures (texturePosition, textureVelocity) {\n    const posArray = texturePosition.image.data\n    const velArray = textureVelocity.image.data\n    for (let k = 0, kl = posArray.length; k < kl; k += 4) {\n      posArray[k + 0] = rndFS(100)\n      posArray[k + 1] = rndFS(100)\n      posArray[k + 2] = rndFS(100)\n      posArray[k + 3] = rnd(0.1, 1)\n\n      velArray[k + 0] = rndFS(0.5)\n      velArray[k + 1] = rndFS(0.5)\n      velArray[k + 2] = rndFS(0.5)\n      velArray[k + 3] = 0\n    }\n  }\n}\n"],"mappings":"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MAAM,CAAChM,YAAY;MACvBgM,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,iCAAiC,EAAE,EAAE,CAAC;MACxFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,0BAA0B,EAAE,EAAE,CAAC;MACjFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,yBAAyB,EAAG;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;MACFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,2BAA2B,EAAG;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;MACFR,MAAM,CAAC/L,cAAc,GAAI;AAC/B;AACA,OAAO,GAAG+L,MAAM,CAAC/L,cAAc;MACzB+L,MAAM,CAAC/L,cAAc,GAAG+L,MAAM,CAAC/L,cAAc,CAACuM,OAAO,CAAC,yBAAyB,EAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;IACR,CAAK;IACD,QAAQhQ,MAAM,CAAC4C,QAAQ;MACrB,KAAK,UAAU;QACbA,QAAQ,GAAG,IAAIqN,oBAAoB,CAACtD,cAAc,CAAC;QACnD;MACF,KAAK,OAAO;QACV/J,QAAQ,GAAG,IAAIsN,iBAAiB,CAACvD,cAAc,CAAC;QAChD;MACF;QACE/J,QAAQ,GAAG,IAAIuN,iBAAiB,CAACxD,cAAc,CAAC;IACxD;IACI2B,KAAK,GAA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nDE,aAAa,EAAE/P,MAAM,CAAC4M,YAAY,CAACiD,OAAO,CAAC,EAAE;MACrD,CAAO;MACDpS,MAAM,CAACC,IAAI,CAAC2F,QAAQ,CAAC,CAAC1F,OAAO,CAAEC,GAAG,IAAK;QACrC4R,MAAM,CAACnM,QAAQ,CAACzF,GAAG,CAAC,GAAGyF,QAAQ,CAACzF,GAAG,CAAC;MAC5C,CAAO,CAAC;MACF4R,MAAM,CAAChM,YAAY,GAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,GAAGgM,MAAM,CAAChM,YAAY;MACvBgM,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,iCAAiC,EAAE,EAAE,CAAC;MACxFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,0BAA0B,EAAE,EAAE,CAAC;MACjFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,yBAAyB,EAAG;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;MACFR,MAAM,CAAChM,YAAY,GAAGgM,MAAM,CAAChM,YAAY,CAACwM,OAAO,CAAC,2BAA2B,EAAG;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;MACFR,MAAM,CAAC/L,cAAc,GAAI;AAC/B;AACA,OAAO,GAAG+L,MAAM,CAAC/L,cAAc;MACzB+L,MAAM,CAAC/L,cAAc,GAAG+L,MAAM,CAAC/L,cAAc,CAACuM,OAAO,CAAC,yBAAyB,EAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,CAAC;IACR,CAAK;IACD,QAAQhQ,MAAM,CAAC4C,QAAQ;MACrB,KAAK,UAAU;QACbA,QAAQ,GAAG,IAAIqN,oBAAoB,CAACtD,cAAc,CAAC;QACnD;MACF,KAAK,OAAO;QACV/J,QAAQ,GAAG,IAAIsN,iBAAiB,CAACvD,cAAc,CAAC;QAChD;MACF;QACE/J,QAAQ,GAAG,IAAIuN,iBAAiB,CAACxD,cAAc,CAAC;IACxD;IACI2B,KAAK,GAAG,IAAI8B,aAAa,CAAClN,QAAQ,EAAEN,QAAQ,EAAEkE,KAAK,CAAC;IACpD9B,SAAS,CAAChF,MAAM,CAAC8E,MAAM,CAAC;IACxB/I,KAAK,CAACiF,GAAG,CAACsN,KAAK,CAAC;EACpB;EACE,SAAStJ,SAASA,CAACF,MAAM,EAAE;IACzB,IAAI1E,KAAK,CAACC,OAAO,CAACyE,MAAM,CAAC,IAAIA,MAAM,CAACvG,MAAM,GAAG,CAAC,EAAE;MAC9C,MAAMgL,MAAM,GAAG1E,UAAU,CAACC,MAAM,CAAC;MACjC,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgD,KAAK,EAAEhD,CAAC,EAAE,EAAE;QAC9BwK,KAAK,CAAC+B,UAAU,CAACvM,CAAC,EAAEyF,MAAM,CAACrE,UAAU,CAACpB,CAAC,GAAGgD,KAAK,CAAC,CAAC;MACzD;MACMwH,KAAK,CAACgC,aAAa,CAAChE,WAAW,GAAG,IAAI;IAC5C;EACA;EACE,SAASxD,YAAYA,CAACX,eAAe,EAAEG,eAAe,EAAE;IACtD,MAAM6B,QAAQ,GAAGhC,eAAe,CAACiC,KAAK,CAACC,IAAI;IAC3C,MAAMC,QAAQ,GAAGhC,eAAe,CAAC8B,KAAK,CAACC,IAAI;IAC3C,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEC,EAAE,GAAGL,QAAQ,CAAC5L,MAAM,EAAEgM,CAAC,GAAGC,EAAE,EAAED,CAAC,IAAI,CAAC,EAAE;MACpDJ,QAAQ,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5B5I,QAAQ,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5B5I,QAAQ,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5B5I,QAAQ,CAACI,CAAC,GAAG,CAAC,CAAC,GAAGuI,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC;MAC7BxI,QAAQ,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5BzI,QAAQ,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5BzI,QAAQ,CAACC,CAAC,GAAG,CAAC,CAAC,GAAGwI,KAAK,CAAC,GAAG,CAAC;MAC5BzI,QAAQ,CAACC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACzB;EACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}